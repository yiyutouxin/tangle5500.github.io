---
layout:     post
title:      Python 基础
subtitle:   
date:       2019-10-11
author:     Tangle
header-img: img/post-bg-ios9-web.jpg
catalog: true
mathjax: false
tags:
    - Python
---

# 运算符

## 比较运算符

| 运算符 | 作用     |
| :----- | :------- |
| >      | 大于     |
| <      | 小于     |
| <=     | 小于等于 |
| >=     | 大于等于 |
| ==     | 比较     |
| !=     | 不等于   |

## 算数运算符

| 运算符 | 作用 |
| :----- | :--- |
| +      | 加   |
| -      | 减   |
| *      | 乘   |
| /      | 除   |
| //     | 整除 |
| %      | 取余 |
| **     | 次方 |

## 赋值运算符

| 运算符 | 作用     |
| :----- | :------- |
| =      | 等于     |
| +=     | 加等于   |
| -=     | 减等于   |
| /=     | 除等于   |
| //=    | 整除等于 |
| **=    | 次方等于 |
| %=     | 取余等于 |

## 逻辑运算符

| 优先级 | 运算符 | 表达式  | 作用                                                        |
| :----- | :----- | :------ | :---------------------------------------------------------- |
| 1      | not    | not x   | 非（x 为 True 返回 x，否则返回 y。都是 False 返回 False。） |
| 2      | and    | x and y | 与（反转成立的结果，只返回 True，False。）                  |
| 3      | or     | x or y  | 或（两个条件成立返回 y 值，否则返回 False。）               |

## 身份运算符

```Python
a = 123456
b = a
c = 123456

# 判断 b 和 a 是不是同一个123456
b is a # Ture
# 判断 c 和 a 是不是同一个123456
c is a # False
# 判断 c 和 a 是不是同一个123456
c is not a # Ture
```

## 成员运算符

```Pyhton
# h 在 hello 中
'h' in 'hello' # Ture
# h 不在 hello 中
'h' not in 'hello' # False
```

## 运算符优先级

http://tool.oschina.net/commons?type=6

# 字符串

## 字符串前面添加 u，r，b 的含义

|      |                                 |
| :--- | :------------------------------ |
| u    | 代表是对字符串进行 unicode 编码 |
| r    | 非转义的原始字符串              |
| b    | 代表字符串就是bytes             |

## 判断

| 语法                   | 作用                   |
| ---------------------- | ---------------------- |
| 'aaa' in demo          | 判断是否在变量中       |
| demo.startswith('aaa') | 判断是否是字符串开头   |
| demo.endswith('aaa')   | 判断是否是字符串结尾   |
| 'aaa'.isalnum()        | 判断是否有中文字符     |
| 'aaa'.isdecimal()      | 判断是否是十进制       |
| 'aaa'.isnumeric()      | 判断是否为纯数字       |
| 'aaa'.isidentifier()   | 判断是否为有效标识符   |
| 'aaa'.islower()        | 判断是否都为都为小写   |
| 'aaa'.isupper()        | 判断是否都为都为大写   |
| 'aaa'.isspace()        | 判断是否所有都为空字符 |

## 切片

```Python
demo[6:]
```

## 运算

```Python
'aaa'*5
```

## 字符串拼接

```Python
demo = ''.join(['a','b'])
```

## 统计

统计元素

```Python
demo.count('a')
```

## 填充

```Python
居中
demo.center(20,'*')
右侧填充
demo.ljust(20,'*')
左侧填充
demo.rjust(20,'*')
```

## 查

```Python
查找到第一个元素并将索引值返回，找不到返回 -1。
demo.find('aaa')
查找到第一个元素并将索引值返回，找不到报错。
demo.index('aaa')
```

## 改

```Python
首字母大写
demo.capitalize()
所有字母小写
demo.lower()
所有字母大写
demo.upper()
替换
demo.replace('aaa','bbb',1)
以空格分隔的单词首字母大写
demo.istitle() 
大小写字母互换
'My title'.swapcase()
```

## 删

```Python
# 删除前后端的空字符
demo.strip()
# 删除前端空字符
demo.lstrip()
# 删除后端空字符
demo.rstrip()
```

## 分割

```Python
demo.split('a',3)
```

## 格式化输出

```Python
demo = '{name}{age}'.format(name='Love',age='20')
demo = '{name}{age}'.format_map({'name':'Love','age':20})
demo = demo ='{}'.format(233)
```

| 语法 | 作用     |
| ---- | -------- |
| %d   | 整数     |
| %.5f | 浮点数   |
| %x   | 十六进制 |
| %s   | 字符串   |

## 字符串转换其他类型

```
eval()
```

# 列表

## 创建列表

```Python
# 创建列表
a=list(['a','b','c'])
# 创建列表
a=['a','b','c']
```

## 查

```Python
# 查看列表的长度
print(len(a))
# 统计字符串，列表内元素的个数
a.count('数据')
# 根据内容找索引值
a.index('b') # 1
# 使用列表推导式进行查找，返回所有为5索引值，以列表形式返回
b = [i for i,x in enumerate(a) if x == 5]
```

## 增

```Python
# 默认插到最后一个位置
a.append('数据')
# 将数据插入到任意一个位置
a.insert(索引,'数据')
# b列表里的值加入到a列表内b列表不变
a.extend(b)
```

## 改

``` Python
# 修改指定索引值的值
a[索引]='数据'
# 修改索引值，不包括3，值可以添加多个['a','b','c']
a[1:3]=['a','b']
# 列表内的值反转
a.reverse()
```

## 删

```Python
# 删除第一个出现的指定值
a.remove('数据')
# 删除索引值的值
a.remove(a[0])
# 删除列表中的列表中的指定值和索引值
a.remove(['a','b'])
# 删除索引值的值，并返回删除的值
b=a.pop(索引)
# 删除列表末尾的值
b=a.pop()
# 清空列表，剩下空列表
a.clear()
# 删除指定索引值的值
del a[索引]
# 删除列表a
del a
```

## 排序

```Python
# ASCII升序排序
a.sort()
# ASCII降序排序
a.sort(reverse=True)
# 逆序，反转
a.reverse()
```

## 切片

切片的三个参数
第一个默认值为0，即最开始包括第一个
第二个默认值为最后，包括最后一个
第三个是步长，默认值为1

```Python
# ['a', 'b', 'c']# 从头取到最后
print(a[0:])
# 取到倒数第二值，不可以取倒数第一个值
print(a[1:-1])
# 从左到右一个一个去取
print(a[1:-1:1])
# 从左到右隔一个去取
print(a[1::2])
```

## 身份判断

```Python
# 创建一个空列表
a=list()
# 身份判断 True or Fulse
type(a) is list
```

# 元组

元组的元素不能修改。

元组的下标索引从0开始，可以进行截取，组合等。

## 创建元组

元组中只包含一个元素时，需要在元素后面添加逗号，如下实例：

```Python
>>> tup1 = ('a','b','c')
>>> tup3 = 'a','b'
>>> tup2 = (1,)
>>> tup4 = ()
>>> print(type(tup3))
<class 'tuple'>
```

## 访问元组

元组可以使用下标索引来访问元组中的值，如下实例：

```python
>>> tup1 = ('a','b','c','d')
>>> tup2 = (1,2,3,4,5,6,7)
>>> print(tup1[0])
a
>>> print(tup2[1:5])
(2, 3, 4, 5)
```

## 修改元组

元组中的元素值是不允许修改的，但我们可以对元组进行链接组合，如下实例：

```python
>>> tup1 = (520,1314)
>>> tup2 = ('a','b')
>>> tup3 = tup1 + tup2
>>> tup3
(520, 1314, 'a', 'b')
```

## 删除元组

元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例：

```python
>>> tup = ('a','b',2018,)
>>> tup
('a', 'b', 2018)
>>> del tup
>>> tup
Traceback (most recent call last):
  File "<input>", line 1, in <module>
NameError: name 'tup' is not defined
```

## 元组运算符

与字符串一样，元组之间可以用 + 号和 * 号进行运算。这就以为这他们可以组合和复制，运算后会生成一个新的元组。

| 表达式                     | 结果                 | 作用         |
| :------------------------- | :------------------- | :----------- |
| len((1,2,3))               | 3                    | 计算元素个数 |
| (1,2,3) + (4,5,6)          | (1,2,3,4,5,6)        | 连接         |
| ('520',) * 3               | ('520','520','520',) | 复制         |
| 3 in (1,2,3)               | True                 | 元素是否存在 |
| for x in (1,2,3):print(x) | 1 2 3                | 迭代         |

## 参考

http://www.runoob.com/python/python-tuples.html

# 字典

无序，键唯一

## 创建字典

``` Python
# 创建字典
a=dict(a=1,b=2,c=['d','e'],f=6)
# 创建字典
a={'a':1,'b':2,'c':['d','e'],'f':6}
```

## 查

```Python
# 打印出键和值,每个键值对用换行符分开i，v分别接收键和值
for i,v in a.items():
# 按键排序查看，不修改
print(sorted(a.items()))
# 通过键查找值
print(a['b'])
# 打印出字典中所有的键
print(list(a.keys()))
# 打印出字典中所有的值
print(list(a.values()))
# 打印出字典中所有的键值对
print(list(a.items()))
# b键值是否在字典a中，在返回Ture，不在返回False
print(b in a)
# 如果键f键存在返回f的值，不存在返回h，默认返回None
print(a.get('f','h'))
```

## 改

```Python
# 修改b的值为30
a=['b']=30
```

## 增

``` Python
# 无序添加到字典内，元素和值
a['k']=20
# 在字典中增加新的键值对，并返回相应的值
b=a.setdefault('g':'g')
# 字典b中的键值对添加到字典a中，字典b不变
a.update(b)
```

## 删

```Python
# 清空字典，只剩大括号
a.clar()
# 删除字典b键的键值对
del a['b']
# 删除整个字典
del a
# 同上,删除的值可以用print，和其他变量接收，有相同以最后的值为准
a.pop('b'))
# 删除最后一组键值对，并以元组方式返回
a.popoitem()
```

## 特殊

```Python
# 创建一个值相同的字典，值可以为数字，列表，字典
>>> dict.fromkeys(['a','b'],['c','d',]) # {'a': ['c', 'd'], 'b': ['c', 'd']}
>>> a['a'][1]='e'
>>> a
# 修改后的a键和b键的值都变了
{'a': ['c', 'e'], 'b': ['c', 'e']}
```

# 集合

无序不重复，自动去重

set 集合必须是可哈希的自身是不可哈希的。

frozenset 集合必须是可哈希自身也是可哈希的与 set 相反。

## 创建集合

```python
>>> a = ['a', 'b', 'c', 1]
>>> b = set(a)
>>> b
{'b', 'c', 'a', 1}
>>> print(type(b))
<class 'set'>
```

## 访问集合

由于集合本身是无序的，所以不能为集合创建索引或切片操作，只能循环遍历或使用in，not in来访问或判断集合元素

```Python
>>> b = set(['a','b','c',1])
>>> '1' in a # 1在b中 # True
>>> '1' not in a # 1在b中 # False
```

## 更新集合

```Python
>>> b = set(['a','b','c',1])
# add为集合添加一个'666'元素
>>> b.add('666')
>>> b # {1, 'c', 'a', '666', 'b'}
# 把字符串qw分割加入集合内
>>> b.update('qw')
>>> b # {'q', 1, '666', 'c', 'b', 'w', 'a'}
# 列表内的元素分别加入集合内
>>> b.update(['d',2])
>>> b # {'q', 1, '666', 2, 'd', 'c', 'b', 'w', 'a'}
```

## 集合类型操作符

```python
>>> a = set([1,2,3,4,5])
>>> b = set([4,5,6,7,8])
```

| 语法                      | 字符   | 结果                     | 作用                               |
| :------------------------ | :----- | :----------------------- | :--------------------------------- |
| a.intersection(b)         | a & b  | {4, 5}                   | 交集（两个集合中都有的元素）       |
| a.union(b)                | a \| b | {1, 2, 3, 4, 5, 6, 7, 8} | 合集（两个集合合并到一起）         |
| a.difference(b)           | a - b  | {1, 2, 3}                | 差集（a中有的b中没有）             |
| a.symmetric_difference(b) | a ^ b  | {1, 2, 3, 6, 7, 8}       | 对称差集（两个集合中不重复的元素） |

## 关系测试

```Python
>>> set('abc') == set('abccc') # True
>>> set('abc') < set('abc') # False
# 只显示and后的集合
>>> set('abc') and set('cde') # {'e', 'c', 'd'}
# 只显示or前的集合
>>> set('abc') or set('cef') # {'c', 'b', 'a'}
```

## 删除集合

``` Python
# 创建列表并转换为集合
>>> a = set([1,2,3,4,5])
# 删除集合内的元素
>>> a.remove(3)
# 查看a集合
>>> a # {1, 2, 4, 5}
# 随机删除一个元素，并返回被删除的元素
>>> a.pop() # 1
# 清空集合
>>> a.clear()
# 查看a集合
>>> a # set()
# 删除集合
>>> del a
```

# 判断

```Python
#如果
if
#否则
elif
#否则
else
```

| 语法                          | 作用                           |
| ----------------------------- | ------------------------------ |
| 变量.isalnum()                | 所有字符都是数字或者字母       |
| 变量.isalpha()                | 所有字符都是字母               |
| 变量.isdigit()                | 所有字符都是数字               |
| 变量.islower()                | 所有字符都是小写               |
| 变量.isupper()                | 所有字符都是大写               |
| 变量.istitle()                | 所有单词都是首字母大写，像标题 |
| 变量.isspace()                | 所有字符都是空白字符 \t \n \r  |
| type(eval('123')) == int      | 判断字符串是否为 int           |
| type(eval("123.23")) == float | 判断字符串是否为 float         |

# 循环

循环条件必须是可迭代对象。

| 语法                  | 作用               |
| :-------------------- | :----------------- |
| range(起始,结束,步长) |                    |
| for i in 条件:        | 有限循环和循环遍历 |
| while 条件:           | 无限循环           |
| continue              | 结束当次循环       |
| break                 | 跳出循环           |

# 迭代器

![](https://img2018.cnblogs.com/blog/1532318/201903/1532318-20190323232701000-1454152611.jpg)

内部有next方法，内部有tier方法。

## 迭代器创建

```Python
>>> x = [1,2,3]
>>> y = iter(x)
>>> type(y)
<class 'list_iterator'>
```

# 生成器

![](https://img2018.cnblogs.com/blog/1532318/201903/1532318-20190323232621241-1721430520.jpg)

普通生成器

```Python
g = (x for x in range(5))
# g现在就是一个生成器
print(g) # <generator object <genexpr> at 0x0000029DA3E114F8>
# 每打印一次返回一个元素的值直到计算最后一个元素的值
print(next(g))
# 也可以使用for循环
for i in g:
    print(i) # 0 1 2 3 4
```

函数生成器

```Python
def fib(max):
    n,a,b= 0,0,1
    while n < max:
        yield b
        a,b= b,a+b
        n+= 1
    return 'done'
g=fib(5)
print(g) # <generator object fib at 0x000002441FF724F8>
for i in g:
    print(i) # 1 1 2 3 5
```

## next

| 语法             |
| :--------------- |
| next(可迭代对象) |

## send

```Python
import time
def consumer(name):
    print("%s 准备吃包子啦!" % name)
    while True:
        baozi= yield
        print("包子[%s]来了,被[%s]吃了!" % (baozi, name))
def producer(name):
    c= consumer('A')
    c2= consumer('B')
    # 调用生成器
    next(c)
    # 调用生成器
    next(c2)
    print("%s,老子开始准备做包子啦!"%name)
    for i in range(10):
        time.sleep(0.5)
        print("做了2个包子!")
        # 继续调用生成器并把值赋给第一次调用的yield
        c.send(i)
        # 继续调用生成器并把值赋给第一次调用的yield
        c2.send(i)
# 调用priducer函数
producer("Tangle")
```

# 函数

## 函数创建

形参是被调用参数，实参是调用参数，形参和实参个数类型要一一对应，如下实例：

```Python
def add(x,y):
    print(x+y)
add(1,1)
```

## 参数优先级顺序

```Python
def a(name,age=12,*args,**kwargs):
    print('name:%s'%name)
    print(age)
    print(args)
    print(kwargs)
a('a',20,'b','c','d',e=1,f=2)
```

结果

```python
name:a
20
('b', 'c', 'd')
{'e': 1, 'f': 2}
```

## 函数返回值

函数里如果没有return，默认返回一个None。

return多个对象，解释器会把多个对象组成一个元组整体输出 。

函数return下面的代码不会执行。

```Python
def a( ):
    return 10,'a',20
    print('666')
print(a())
```

结果

```python
(10, 'a', 20)
```

## 函数特性

函数可以作为参数，可以赋值给变量，也可以作为返回值。

```Python
def c(q):
    return q
def a(n):
    return n+n
def b(d,e):
    # 函数作为返回值
    return e(d),f(1314)
# 函数赋值给变量
f = c
# 函数作为参数
print(b(260,a))
```

结果

```python
(520, 1314)
```

## 函数作用域

| 搜索顺序 | 变量      | 说明                                     |
| :------- | :-------- | :--------------------------------------- |
| 1        | local     | 局部作用域，即函数中定义的变量           |
| 2        | enclosing | 嵌套的父级函数的局部作用域。             |
| 3        | global    | 全局变量，就是模块级别定义的变量         |
| 4        | built-in  | 系统固定模块的变量，比如int，bytearray等 |

作用域声明函数

| 作用域             | 语法            | 作用                 | 声明前                                                         | 声明后                                                 |
| :----------------- | :-------------- | :------------------- | :------------------------------------------------------------- | :----------------------------------------------------- |
| 局部作用域         | global 变量名   | 局部全局变量互相修改 | 局部只能使用全局变量不能修改，全局不可以使用局部内的变量。     | 局部可以修改全局变量，全局不可以修改局部内的变量。     |
| 嵌套函数局部作用域 | global 变量名   | 同上。               | 同上。                                                         | 同上。                                                 |
| 嵌套函数局部作用域 | nonlocal 变量名 | 嵌套函数修改局部变量 | 嵌套函数只能使用局部变量不能修改，局部不可以使用嵌套内的变量。 | 嵌套函数可以修改局部变量，局部不可以使用嵌套内的变量。 |

局部作用域

```Python
gcount = 0
def global_test():
    global gcount
    gcount += 20
    print(gcount)
global_test()
```

嵌套函数局部作用域

``` Python
def make_counter():
    count = 0
    def counter():
         nonlocal count
         count+= 20
         print(count)
    counter()
make_counter()
```

全局变量

```Python
a = 10
```

系统固定模块的变量

```Python
x = int(2.9)
```

## 递归函数

在函数内部，可以调用其他函数，如果一个函数在内部调用自身本身，这个函数就是递归函数。

阶乘

```Python
# for循环
def factorial(n):
    result = n
    for i in range(1, n):
        # 1*2*3*4*5
        result+= i
    return result
print(factorial(5))

# 递归函数
def factorial_new(n):
    if n == 1:
        return 1
    # 5*4*3*2*1
    return n * factorial_new(n - 1)
print(factorial_new(5))
```
斐波那契数列

```Python
# for循环
def fibo(n):
    # 斐波那契数列第1个数字
    before= 0
    # 斐波那契数列第2个数字
    after = 1
    # 循环7次
    for i in range(n - 2):
        current = before + after
        before= after
        after= current
    return current
print(fibo(9))

# 递归函数
def fibo(n):
    if n <= 2:
        # 当前数列
        return n-1
        # 当前数列
    return fibo(n-1)+fibo(n-2)
print(fibo(9))
```

## filter

| 语法      | 参数        |
| :-------- | :---------- |
| filter(,) | 函数名,序列 |

```Python
str = ['a', 'b', 'c', 'd']
def fun1(s):
    if s != 'a':
        return s
# filter可以把函数实参这样执行
ret = filter(fun1,str)
# ret是一个迭代器对象
print(list(ret))
```

## map

| 语法   | 参数        |
| :----- | :---------- |
| map(,) | 函数名,序列 |

```Python
a = ['a','b','c','d']
def fun2(s):
    return s + 'alvin'
# map可以把函数实参这样执行
ret= map(fun2,a)
# ret是一个迭代器
print(ret) # <map object at 0x000001128F9A9358>
print(list(ret)) # ['aalvin', 'balvin', 'calvin', 'dalvin']

def add(x,y):
    return x+y
print (list(map(add, range(10), range(10)))) # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

## reduce

| 语法       | 参数               |
| :--------- | :----------------- |
| reduce(,,) | 函数名,序列,起始值 |

```Python
# 调用reduce函数必须添加这句话
from functools import reduce
def add1(x, y):
    return x + y
# 1+2+3+4
print(reduce(add1, range(1,5))) # 10
# 1+2+3+4+20
print(reduce(add1, range(1, 5), 20)) # 30
```

## lambda

```Python
# 普通函数
def add(a, b):
    return a + b
print(add(2, 3)) # 5

# 匿名函数
add = lambda a,b : a + b
print(add(2,3)) # 5
```

## 闭包函数

```Python
# 第一层函数
def a(b):
    # 第二层函数
    def c():
        # 在第二层函数调用第一层函数就是闭包
        print(b)
    return c
a(10)() # 10
```

# 异常处理

| 语法     | 作用                 |
| -------- | -------------------- |
| try:     | 执行此代码           |
| except:  | 发生异常执行此代码   |
| else:    | 没有异常执行此代码   |
| finally: | 是否异常都执行此代码 |

```python
try:
    int('demo')
except(NameError,ValueError):
    print('demo1')
except:
    print('demo2')
else:
    print('demo3')
finally:
    print('demo4')
```

## 捕获异常

| 语法                    | 作用         |
| ----------------------- | ------------ |
| except ValueError as e: | 捕获指定异常 |
| except Exception as e:  | 捕获所有异常 |

``` python
try:
    int('demo')
except NameError as e:
    print('NameError',e)
except ValueError as e:
    print('ValueError',e)
except Exception as e:
    print('Exception',e)
    
    import time
    w = open('log.txt','a+')
    w.write('%s     %s\n'%(time.ctime(),e))
    w.close
```

## 抛出异常

| 语法                     | 作用     |
| ------------------------ | -------- |
| raise Exception('Error') | 抛出异常 |

````python
try:
    raise Exception('Error')
except Exception as e:
    print(e)
````

## 异常判断

| 语法          | 作用                     |
| ------------- | ------------------------ |
| assert 1 == 2 | 条件成立继续执行否则报错 |

```python
assert 1 == 2
print(233)
```

# 面向对象

## 类的创建

| 语法        | 作用     |
| ----------- | -------- |
| class 类名: | 类定义   |
| x = 类名()  | 实例化类 |

```python
class foo:
    def __init__(self):
        self.fun()
    def fun(self):
        print('demo')
foo()
```

### 特殊方法

``` python
def func(self):
    print('hello world')
foo = type('foo',(object,),{'func':func})
```

## 类的方法

| 语法                 | 作用         |
| -------------------- | ------------ |
| def 函数名(self):    | 定义方法     |
| def \__init__(self): | 定义构造方法 |
| 类名().函数名()      | 访问类的方法 |

### 类的私有方法

| 语法                | 作用                                                         |
| ------------------- | ------------------------------------------------------------ |
| def __函数名(self): | 两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。 |
| self.__函数名()     | 在类内部中使用时。                                           |

### 类的专有方法

| 语法           | 作用                       | 外部调用         |
| -------------- | -------------------------- | ---------------- |
| \__init__:     | 构造函数，在生成对象时调用 | 类名()           |
| \__call__:     | 函数调用                   | 类名()()         |
| \__int__       |                            | int(类名())      |
| \__str__       |                            | str(类名())      |
| \__del__ :     | 析构函数，释放对象时使用   |                  |
| \__repr__ :    | 打印，转换                 |                  |
| \__setitem__ : | 按照索引赋值               | 类名()[0] = 666  |
| \__getitem__:  | 按照索引获取值             | 类名()[1]        |
| \__delitem__:  |                            | del 类名()[2]    |
| \__dict__      | 类成员通过字典形式返回     | 类名().\__dict__ |
| \__len__:      | 获得长度                   |                  |
| \__cmp__:      | 比较运算                   |                  |
| \__add__:      | 加运算                     |                  |
| \__sub__:      | 减运算                     |                  |
| \__mul__:      | 乘运算                     |                  |
| \__truediv__:  | 除运算                     |                  |
| \__mod__:      | 求余运算                   |                  |
| \__pow__:      | 乘方                       |                  |

### 运算符重载

Python 同样支持运算符重载，我们可以对类的专有方法进行重载。

```python
class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b
 
   def __str__(self):
      return 'Vector (%d, %d)' % (self.a, self.b)
   
   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)
 
v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)
```

## 类的属性

| 语法      | 作用         |
| --------- | ------------ |
| 变量 = 0  | 类的属性     |
| 类名.变量 | 访问类的属性 |

### 类的私有属性

| 语法        | 作用                                                         |
| ----------- | ------------------------------------------------------------ |
| __变量 = 0  | 两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。 |
| self.__变量 | 在类内部的方法中使用时。                                     |

## 继承

| 语法                       | 作用               |
| -------------------------- | ------------------ |
| class 子类名(父类名):      | 继承               |
| 父类名.\__init__(self,n,a) | 调用父类的构造函数 |

继承后可以使用父类的方法

```python
class people:
    age = 0
    def __init__(self, a):
        self.age = a
    def speak(self):
        print(self.name,self.age)
        
class student(people):
    name = ''
    def __init__(self, n, a):
        people.__init__(self, a)
        self.name = n

s = student('linux',1970)
s.speak()
```

### 多继承

括号内左侧优先调用，一侧走到黑。

如果有同一个根，根最后执行。

| 语法                   | 作用     |
| ---------------------- | -------- |
| class 子类(父类,父类): | 多重继承 |

### 方法重写

| 语法                             | 作用                             |
| -------------------------------- | -------------------------------- |
| super(子类名, 子类实例).函数名() | 用子类对象调用父类已覆盖的方法。 |

方法重写后如果还想执行父类的方法用 super

```python
class Parent:
    def myMethod(self):
        print('调用父类方法')

class Child(Parent):
    def myMethod(self):
        print('调用子类方法')
        
c = Child()
c.myMethod()
super(Child, c).myMethod()
```

