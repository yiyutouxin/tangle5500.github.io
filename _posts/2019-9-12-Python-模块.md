---
layout:     post
title:      Python 模块
subtitle:   
date:       2019-9-12
author:     Tangle
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Python
---

# 模块导入

| 语法                                         | 作用                                     | 注意                         |
| -------------------------------------------- | ---------------------------------------- | ---------------------------- |
| improt 文件名,文件名                         | 导入单个或多个模块。                     |                              |
| from 文件名 import 函数名,函数名             | 导入单个模块的单个函数或多个函数。       |                              |
| from 文件名 import *                         | 导入模块内所有函数和变量。               |                              |
| import 顶层包.子包.文件名                    | 导入包中的单个模块，用包全称调用。       | 包中必须有 \__init__.py 文件 |
| from 顶层包.子包 import 文件名,文件名        | 导入包中的单个或多个模块，用文件名调用。 | 包中必须有 \__init__.py 文件 |
| from 顶层包.子包.文件名 import 函数名,函数名 | 导入包中的单个或多个函数，用函数调用。   | 包中必须有 \__init__.py 文件 |

# import time

四种类型

| 类型       | 类型   | 作用                                                       |
| :--------- | :----- | :--------------------------------------------------------- |
| 时间戳     | 浮点型 | 时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。 |
| 结构化     | 元组   | 共有9个元素组。                                            |
| 格式化时间 | 字符串 | 已格式化的结构使时间更具可读性。包括自定义格式和固定格式。 |
| 延时       | 无     | 延时。                                                     |

## 时间戳

| 语法          | 作用            |
| :------------ | :-------------- |
| time.time()   | 本地时间        |
| time.clock()  | 计算CPU运行时间 |
| time.mktime() | 本地结构化时间  |

## 结构化时间

| 语法             | 作用           |
| :--------------- | :------------- |
| time.gmtime()    | UTC结构化时间  |
| time.localtime() | 本地结构化时间 |

结构化属性

| 索引 | 属性                      | 值                 |
| :--- | :------------------------ | :----------------- |
| 0    | tm_year（年）             | 2017               |
| 1    | tm_mon（月）              | 1-12               |
| 2    | tm_mday（日）             | 1-31               |
| 3    | tm_hour（时）             | 0-23               |
| 4    | tm_min（分）              | 0-59               |
| 5    | tm_sec（秒）              | 0-61(60或61是润秒) |
| 6    | tm_wday（一周中的第几天） | 0-6（0表示周一）   |
| 7    | tm_yday（一年中的第几天） | 1-366              |
| 8    | tm_isdst（是否是夏令时）  | 默认为0            |

结构化取单个值的两种方法

| 方法 | 作用       |
| :--- | :--------- |
| 1    | 变量.属性  |
| 2    | 变量[索引] |

## 格式化时间

| 语法                      | 作用                                   |
| :------------------------ | :------------------------------------- |
| time.strftime('%Y-%m-%d') | 本地格式化时间                         |
| time.ctime(秒)            | 本地固定格式时间，添加参数从1970年计时 |
| time.asctime(结构化时间)  | 本地固定格式时间                       |

格式化符号

| 符号 | 作用                                      |
| :--- | :---------------------------------------- |
| %Y   | 四位数的年份表示（000-9999）              |
| %m   | 月份（01-12）                             |
| %d   | 日（0-31）                                |
| %H   | 24小时制小时数（0-23）                    |
| %M   | 分钟数（00=59）                           |
| %S   | 秒（00-59）                               |
| %c   | 简化格式化时间                            |
| %x   | 本地相应的日期表示，用/分割               |
| %X   | 本地相应的时间表示，用:分割               |
| %B   | 本地完整的月份名称                        |
| %b   | 本地简化的月份名称                        |
| %A   | 本地完整星期名称                          |
| %a   | 本地简化星期名称                          |
| %j   | 年内的第几天（001-366）                   |
| %p   | 本地AM或PM的等价符，12或24小时制          |
| %U   | 一年中的星期数（00-53）星期天为星期的开始 |
| %w   | 星期（0-6），星期天为星期的开始           |
| %W   | 一年中的星期数（00-53）星期一为星期的开始 |
| %Z   | 当前时区的名称                            |
| %%   | %号本身                                   |
| %y   | 两位数的年份表示（00-99）                 |
| %I   | 12小时制小时数（01-12）                   |

## 种类转换

| 语法                                   | 作用                             |
| :------------------------------------- | :------------------------------- |
| time.strptime('2018-12-17','%Y-%m-%d') | 格式化时间转换结构化时间         |
| time.strftime('%Y-%m-%d',结构化时间)   | 结构化时间转换格式化时间         |
| time.localtime(秒)                     | 时间戳转换结构化时间             |
| time.ctime(秒)                         | 时间戳转换固定格式格式化时间     |
| time.asctime(结构化时间)               | 结构化时间转换固定格式格式化时间 |
| time.mktime(格式化时间)                | 结构化转时间戳                   |

# import datetime

## datetime.datetime.now

```python
# 本地格式化时间
>>> datetime.datetime.now() # 2018-12-16 16:45:20.194687
```

# import random

## random

```python
# 0至1浮点型随机数
>>> random.random() # 0.3137125524227292
```

## randint

```python
# 1至8整数型随机数
>>> random.randint(1,8) # 2
```

## chonice

```python
# 随机打印单个
>>> random.choices('hello') # ['e']
```

## sample

```python
# 随机打印几个元素可调节
>>> random.sample(['a','b','c'],1) # ['c']
```

## randrange

```python
# 1至2随机数可调节
>>> random.randrange(1,3) # 2
```

# import os

## 切换当前工作路径

| 语法                   | 作用             |
| ---------------------- | ---------------- |
| os.chdir(r"C:\Users\") | 切换当前工作路径 |

## 查看当前路径及路径下的文件

| 语法            | 返回值 | 作用                 |
| --------------- | ------ | -------------------- |
| os.getcwd()     | str    | 查看当前目录         |
| os.listdir('.') | list   | 查看当前目录所有文件 |

## 查看绝对路径

| 语法                 | 作用         |
| -------------------- | ------------ |
| os.path.abspath('.') | 返回绝对路径 |

## 查看路径文件夹和文件名

| 语法                                    | 返回值 | 作用                               |
| --------------------------------------- | ------ | ---------------------------------- |
| os.path.split('F:\\Easy Love\\1.py')    | 元组   | 将路径分解为文件夹和文件名         |
| os.path.join('F:\\Easy Love','666')     |        | 拼接路径                           |
| os.path.dirname('F:\\Easy Love\\1.py')  |        | 返回路径中的文件夹部分结尾不包括 \ |
| os.path.basename('F:\\Easy Love\\1.py') |        | 返回路径中的文件名                 |

## 查看文件时间

| 语法                                    | 返回值 | 作用                       |
| --------------------------------------- | ------ | -------------------------- |
| os.path.getmtime('F:\\Easy Love\\1.py') | 时间戳 | 文件或文件夹的最后修改时间 |
| os.path.getatime('F:\\Easy Love\\1.py') | 时间戳 | 文件或文件夹的最后访问时间 |
| os.path.getctime('F:\\Easy Love\\1.py') | 时间戳 | 文件或文件夹的创建时间     |

## 查看文件大小

| 语法                                   | 作用                                            |
| -------------------------------------- | ----------------------------------------------- |
| os.path.getsize('F:\\Easy Love\\1.py') | 文件或文件夹的大小，若是文件夹返回0，字节类型。 |

## 查看文件是否存在

| 语法                                  | 返回值        | 作用             |
| ------------------------------------- | ------------- | ---------------- |
| os.path.exists('F:\\Easy Love\\1.py') | True \| False | 查看文件是否存在 |

## 一些表现形式参数

| 语法       | 作用      |
| ---------- | --------- |
| os.sep     | 表示 \\\  |
| os.extsep  | 表示 .    |
| os.linesep | 表示 \r\n |

# import sys

## sys.argv

实现从程序外部向程序传递参数

## sys.exit

退出程序，正常退出时exit(0)

## sys.path

返回模块的搜索路径，初始化使用Python环境变量的值

## sys.modules

是一个全局字典，该字典是python启动后就加载在内存中，每当程序员导入新的模块，sys.modules将自动记录该模块，当第二次再导入该模块时，python会直接到字典中查找,从而加快了程序运行的速度，它拥有字典所拥有的一切方法

## sys.platform

返回操作系统平台名称

# import hashlib

## md5

```python
# md5加密
m = hashlib.md5()
# b代表字符串就是bytes
m.update(b'hello')
# 等价于(b'helloworld')
b=m.update(b'world')
# 2进制格式hash
print(m.digest()) # b'\xfc^\x03\x8d8\xa5p2\x08TA\xe7\xfep\x10\xb0'
# 16进制格式hash
print(m.hexdigest()) # fc5e038d38a57032085441e7fe7010b0
```

## sha1

```python
# sha1加密
hash = hashlib.sha1()
hash.update(b'admin')
print(hash.hexdigest())
```

# import logging

## logging.getLogger

创建记录器，参数日志名称

## logging.StreamHandler

创建屏幕打印，参数为空

## logging.FileHandler

创建写入文件，参数文件名称

## logging.Formatter

| 日志格式            | 作用                                                         |
| :------------------ | :----------------------------------------------------------- |
| %(name)s            | Logger的名字                                                 |
| %(levelno)s         | 数字形式的日志级别                                           |
| %(levelname)s       | 文本形式的日志级别                                           |
| %(pathname)s        | 调用日志输出函数的模块的完整路径名，可能没有                 |
| %(filename)s        | 调用日志输出函数的模块的文件名                               |
| %(module)s          | 调用日志输出函数的模块名                                     |
| %(funcName)s        | 调用日志输出函数的函数名                                     |
| %(lineno)d          | 调用日志输出函数的语句所在的代码行                           |
| %(created)f         | 当前时间，用UNIX标准的表示时间的浮点数表示                   |
| %(relativeCreated)d | 输出日志信息时的，自Logger创建以来的毫秒数                   |
| %(asctime)s         | 字符串形式的当前时间，默认格式是'2003-07-08 16:49:45,896'逗号后面的是毫秒 |
| %(thread)d          | 线程ID，可能没有                                             |
| %(threadName)s      | 线程名，可能没有                                             |
| %(process)d         | 进程ID，可能没有                                             |
| %(message)s         | 用户输出的消息                                               |

## setFormatter

给屏幕打印和文件写入添加日志格式

## addHandler

将屏幕打印和文件写入添加到记录器中

## 日志等级

```python
# 调试
debug('')
# 信息
info('')
# 警告
warn('')
# 错误
erroe('')
# 严重
critical('')
```

日志记录器

```python
#日志记录器
import logging
# 创建记录器,参数写日志名
logger = logging.getLogger('TEST-LOG')
# 日志等级
logger.setLevel(logging.DEBUG)
# 屏幕打印
ch = logging.StreamHandler()
# 日志等级
ch.setLevel(logging.DEBUG)
# 文件写入,参数写文件名
fh = logging.FileHandler("access.log")
# 日志等级
fh.setLevel(logging.DEBUG)
)# 创建日志格式
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'
# 将日志格式添加到ch
ch.setFormatter(formatter)
# 将日志格式添加到fh
fh.setFormatter(formatter)
# 将ch屏幕打印添加到记录器
logger.addHandler(ch)
# 将fh文件写入添加到记录器
logger.addHandler(fh)
# 日志记录
logger.debug('debug message')
# 日志记录
logger.info('info message')
# 日志记录
logger.warn('warn message')
# 日志记录
logger.error('error message')
# 日志记录
logger.critical('critical message')
```

# import re

根据条件匹配，条件匹配结束后内容没有匹配完，反复使用条件匹配直到所有内容匹配完为止。

## 元字符

| 元字符 | 作用                                                   |
| :----- | :----------------------------------------------------- |
| .      | 除\n代表任意字符                                       |
| ^      | 只能从头开始匹配                                       |
| $      | 只能从结尾开始匹配                                     |
| +      | 前的一个字符1至n次匹配                                 |
| *      | 字符串前端能匹配几个是几个，全匹上前一个字符0至n次匹配 |
| {1,2}  | 前的一个字符匹配1个或2个字符串，直到匹配结束           |
| ?      | 只能匹配0次或1次                                       |
| [^]    | 取反                                                   |
| \|     | 匹配到其中一个就可以                                   |
| ()     | 只显示分组内的匹配                                     |
| (?:)   | 分组有权限用?:去除就可以全部显示了                     |
| \d     | 匹配任意数字，同[0-9]                                  |
| \D     | 匹配非数字，同[^0-9]                                   |
| \s     | 匹配任何空白字符，同[ \t\n\r\f\v]                      |
| \S     | 匹配非空白字符，同[^\s]                                |
| \w     | 匹配包括下划线在内的任何字母数字，同[a-zA-Z0-9_]       |
| \W     | 匹配特殊字符，同[^a-zA-Z0-9_]                          |
| \b     | 匹配一个有特殊字符边界的字符,比如空格，&，#            |
| \B     | 匹配一个没有特殊字符边界的字符，比如空格，&，#         |
| \A     | 仅匹配字符串开头，同^                                  |
| \Z     | 仅匹配字符串的结尾，同$                                |

## findall

```python
# 元字符，所有结果都返回一个列表内

# .除\n代表任意字符
>>> re.findall('h..lo','hello world') # ['hello']
# ^只能从头开始匹配
>>> re.findall('^hello','hello world') # ['hello']
# $只能从结尾开始匹配
>>> re.findall('hello$','hello world') # []
# +前的一个字符1至∞次匹配
>>> re.findall('hello+','hellooo world') # ['hellooo']
# *字符串前端能匹配几个是几个，全匹上前一个字符0至∞次匹配
>>> re.findall('helo*','hellooo world') # ['hel']
# {1,2}前的一个字符匹配2次，可调节
>>> re.findall('hello{1,2}','hellooo world') # ['helloo']
# ?只能匹配0次或1次
>>> re.findall('a?b?c', 'aac') # ['ac']
# [^]取反
>>> re.findall('a[^\d]d','acd') # ['acd']
# |匹配到其中一个就可以
>>> re.findall('a|b','aabb') # ['a', 'a', 'b', 'b']
# ()只显示分组内的匹配
>>> re.findall('123(ab)','123abc') # ['ab']
# (?:)分组有权限用?:去除就可以全部显示了
>>> re.findall('123(?:ab)','123abc') # ['123ab']
```

## search

返回匹配到的一个对象，可以调用以下方法返回结果

| 语法    | 返回类型 | 作用                                   |
| :------ | :------- | :------------------------------------- |
| group() | str      | 返回被 re 匹配到的字符串。             |
| start() | int      | 返回匹配开始的位置。                   |
| end()   | int      | 返回匹配结束的位置。                   |
| span()  | tuple    | 返回一个元组，包含匹配开始结束的位置。 |

```python
# (?p<>)是分组命名格式，|是或的意识
>>> a=re.search('(?P<id>\d{2})|(?P<name>\w{3})','2/com')
# 调用search中匹配到的字符
>>> a.group() # 'com'
# 调用名字为id分组匹配结果
>>> a.group('id')
# 调用名字为name分组匹配的结果
>>> a.group('name') # 'com'
```

## match

只在字符串开始匹配,返回一个对象，对象可以调用group，返回结果

```python
# 创建规则对象
obj = re.compile(r'www.*.com')
# 现在b就是一个对象
b = a.match('www.baidu.com')
print(b) # <_sre.SRE_Match object; span=(1, 14), match='www.baidu.com'>
```

## split

分割字符串

```python
# 用cd分割
>>> re.split('cd','abcdef') # ['ab', 'ef']
# 先用c分割再用d分割
>>> re.split('[cd]','abcdef') # ['ab', '', 'ef']
```

## sub

修改字符串

```python
# 3是个数参数，默认为全部修改
>>> re.sub('a','b','aaaaa'1,3) # 'bbbaa'
# 10是个数参数，默认为全部修改
>>> re.subn('a','b','aaaaa',10)
```

## compole

创建的compole规则对象可以用re其他方法调用

```python
# 创建规则对象
>>> object=re.compile(r'www.*.com')
# 用规则对象进行匹配
>>> object.findall('aaawww.bbb.comccc') # ['www.bbb.com']
```

## findtier

返回的是一个迭代器

```python
import re
b=re.finditer('\d','1a2b3c')
a=0
while True:
    if a<3:
        print(next(b).group()) # 1 2 3
        a+=1
    else:
        break
```

# import json

我们把对象(变量)从内存中变成可储存或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也称之为serialization、marshalling、flattening等等，都是一个意识。

序列化之后就可以把序列化后的内容写入磁盘，或者通过网络传输到其他机器上反之，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling

如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的办法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便存储到磁盘或者通过网络传输JSON不仅是标注格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便

## 序列化

```python
import json
dic={'name':'tangle','age':23,'sex':'male'}
print(type(dic)) # <class 'dict'>
j=json.dumps(dic)
print(type(j)) # <class 'str'>
f=open('序列化对象','w')
f.write(j) # 或 json.dump(dic,f)
f.close()
```

## 反序列化

```python
import json
f = open('序列化对象')
data = json.loads(f.read()) # 或 data=json.load(f)
print(data)
f.close
```

# import pickle

## 序列化

```python
import pickle
dic = {'name': 'tangle', 'age': 23, 'sex': 'male'}
print(type(dic)) # <class 'dict'>
j = pickle.dumps(dic)
print(type(j)) # <class 'bytes'>
# w是写入str，wb是写入bytes，j是bytes类型
f = open('序列化对象', 'wb')
# 等价于 pickle.dump(dic,f)
f.write(j)
f.close()
```

## 反序列化

```python
import pickle
f = open('序列化对象', 'rb')
# 等价于 data=pickle.load(f)
data = pickle.loads(f.read())
print(data['age'])
```

# import shelve

shelve模块比pickle模块简单，只有一个open函数，返回类似字典的对象，可读可写，key必须为字符串，而值可以是Python所有支持的数据类型。

## 序列化

```python
import shelve
# 打开文件
f= shelve.open(r'shelve.txt')
# 写入文件
f['info_1']={'name':'tangle','age':'18'}
f['info_1']={'name':'python','age':'27'}
f.close()
```

## 反序列化

```python
import shelve
# 打开文件
f = shelve.open(r'shelve.txt')
print(f.get('stu1_info')['age'] )# 18
data=f.get('school_info')
print(data)# {'website': 'oldboyedu.com', 'city': 'beijing'}
```

# import win32

## 窗口

| 语法                                                 | 输出          | 作用                         |
| ---------------------------------------------------- | ------------- | ---------------------------- |
| win32api.GetSystemMetrics(win32con.SM_CXSCREEN)      | 宽度分辨率    | 获取宽度分辨率。             |
| win32api.GetSystemMetrics(win32con.SM_CYSCREEN)      | 高度分辨率    | 获取高度分辨率。             |
| left,top,right,bottom = win32gui.GetWindowRect(句柄) | (左,上,右,下) | 获取窗口左上角和右下角坐标。 |
| win32gui.PostMessage(hwnd, win32con.WM_CLOSE,0,0)    |               | 关闭窗口                     |
| win32gui.SetForegroundWindow(hwnd)                   |               | 设置为前台                   |
| win32gui.SetForegroundWindow(句柄)                   |               | 窗口置顶                     |

| 语法                                         | 参数               | 做用                                                       |
| -------------------------------------------- | ------------------ | ---------------------------------------------------------- |
| win32gui.ShowWindow(句柄, win32con. SW_HIDE) | SW_HIDE            | 隐藏窗口，大小不变，激活状态不变。                         |
|                                              | SW_MAXIMIZE        | 最大化窗口，显示状态不变，激活状态不变。                   |
|                                              | SW_MINIMIZE        | 最小化窗口，显示状态不变，激活状态不变。                   |
|                                              | SW_RESTORE         | 从最大化或最小化恢复正常大小，显示状态不变，激活状态不变。 |
|                                              | SW_SHOW            | 显示并激活窗口，大小状态不变。                             |
|                                              | SW_SHOWMAXIMIZED   | 显示并激活窗口，以最大化显示。                             |
|                                              | SW_SHOWMINIMIZED   | 显示并激活窗口，以最小化显示。                             |
|                                              | SW_SHOWMINNOACTIVE | 显示窗口并最小化，激活状态不变。                           |
|                                              | SW_SHOWNA          | 显示窗口，大小状态不变，激活状态不变。                     |
|                                              | SW_SHOWNOACTIVATE  | 显示并从最大化或最小化恢复正常大小，激活状态不变。         |
|                                              | SW_SHOWNORMAL      | 显示并激活窗口，恢复正常大小。                             |

## 句柄

| 语法                                                         | 输出                    | 作用                                                 |
| ------------------------------------------------------------ | ----------------------- | ---------------------------------------------------- |
| win32gui.FindWindow('类名', '窗口标题')                      | 句柄                    | 通过类名标题获取窗口句柄，类名不知道可以填写 0。     |
| win32gui.GetWindowRect(句柄)                                 | (x坐标,y坐标,宽度,高度) | 返还窗口信息元祖类型                                 |
| win32gui.FindWindowEx(句柄, None, 类名, 窗口标题)            | 句柄                    | 通过父句柄获取子句柄                                 |
| hwndChildList = []<br>win32gui.EnumChildWindows(句柄, lambda hwnd, param: param.append(hwnd),hwndChildList) |                         | 根据句柄列出子句柄，如果句柄为 None 列出所有主句柄。 |

## 鼠标

| 语法                                                         | 输出           | 作用             |
| ------------------------------------------------------------ | -------------- | ---------------- |
| win32api.GetCursorPos()                                      | (x坐标, y坐标) | 获取鼠标坐标。   |
| win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,0,0,0,0)  |                | 鼠标左键按下     |
| win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,0,0,0,0)    |                | 鼠标左键弹起     |
| win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTDOWN,0,0,0,0) |                | 鼠标右键按下     |
| win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP,0,0,0,0)   |                | 鼠标右键弹起     |
| win32api.SetCursorPos((x, y))                                |                | 设置鼠标位置     |
| win32api.SendMessage(句柄,win32con.WM_LBUTTONDOWN,win32con.MK_LBUTTON,win32api.MAKELONG(x坐标,y坐标)) |                | 后台鼠标左键按下 |
| win32api.SendMessage(句柄,win32con.WM_LBUTTONUP,win32con.MK_LBUTTON,win32api.MAKELONG(x坐标,y坐标)) |                | 后台鼠标左键弹起 |

## 键盘

| 语法                                  | 作用     |
| ------------------------------------- | -------- |
| win32gui.SetForegroundWindow(0)       | 绑定窗口 |
| win32api.keybd_event(键代码, 0, 0, 0) | 按下     |
| win32api.keybd_event(键代码, 0, 0, 0) | 弹起     |

## 根据句柄获取句柄标题和类名

| 语法                                  | 输出 | 作用     |
| ------------------------------------- | ---- | -------- |
| title = win32gui.GetWindowText(句柄)  | 标题 | 获取标题 |
| clsname = win32gui.GetClassName(句柄) | 类名 | 获取类名 |

## 菜单

| 语法                                                       | 作用                |
| ---------------------------------------------------------- | ------------------- |
| menu = win32gui.GetMenu(句柄)                              | 获取第几个主菜单    |
| menu1 = win32gui.GetSubMenu(menu, 0)                       | 获取第几个主菜单    |
| cmd_ID = win32gui.GetMenuItemID(menu1, 2)                  | 获取第几个子菜单 ID |
| win32gui.PostMessage(句柄, win32con.WM_COMMAND, cmd_ID, 0) | 点击菜单            |

```python
import win32con
import win32gui

hwnd = win32gui.FindWindow('SciCalc','计算器')
menu = win32gui.GetMenu(hwnd)
menu1 = win32gui.GetSubMenu(menu, 0)
cmd_ID = win32gui.GetMenuItemID(menu1, 1)
win32gui.PostMessage(hwnd, win32con.WM_COMMAND, cmd_ID, 0)

def get_menu_item_txt(menu,idx):
    import win32gui_struct
    # 新建一个win32gui的空的结构体mii
    mii, extra = win32gui_struct.EmptyMENUITEMINFO()
    # 将子菜单内容获取到mii
    win32gui.GetMenuItemInfo(menu, idx, True, mii)
    # 解包mii
    ftype, fstate, wid, hsubmenu, hbmpchecked, hbmpunchecked,\
    dwitemdata, text, hbmpitem = win32gui_struct.UnpackMENUITEMINFO(mii)
    return text

for i in range(3):
    print(get_menu_item_txt(menu,i))

for i in range(2):
    print(get_menu_item_txt(menu1,i))
```

#  import threading

| 语法                                                | 作用                                       |
| --------------------------------------------------- | ------------------------------------------ |
| t = threading.Thread(target = 函数名,args = (参数)) | 创建线程。                                 |
| t.start()                                           | 执行线程调用创建线程中的函数。             |
| t.setDaemon(True)                                   | 每个线程设置此方法，主线程结束子线程也结束 |
| threading.active_count()                            | 查看当前运行多少个线程                     |
| t.join()                                            | 等待线程结束                               |

```python
import threading

def demo():
    while True:
        if not ev1.wait(): break

ev1 = threading.Event()
ev1.set()

t = threading.Thread(target=demo)
t.start()

ev1.clear()
```

## 线程锁

禁止 cpu 切换，锁中的代码串行运行

```python
r = threading.Lock()
r.acquire()
print('demo')
r.release()
```

可重用锁

```python
r = threading.RLock()
r.acquire()
print('demo')
r.release()
```

信号量

```python
semaphore=threading.BoundedSemaphore(5)
r.acquire()
print('demo')
r.release()
```

# import configparser

## 创建 config.ini

| 语法                                    | 作用     |
| --------------------------------------- | -------- |
| config = configparser.ConfigParser()    | 实例化   |
| config['DATE'] = {'date': '2019-05-08'} | 设置配置 |

```python
import configparser

config = configparser.ConfigParser() # 注意大小写
config['DATE'] = {'date': '2019-05-08'}

with open('f:\config.ini', 'w') as configfile:
    config.write(configfile)
```

## 读取 config.ini

| 语法                    | 返回值       | 作用           |
| ----------------------- | ------------ | -------------- |
| config.sections()       | 列表         | 获取所有项     |
| config.items('DATE')    | 列表嵌套元组 | 获取项的键和值 |
| config.options('DATE')  | 列表         | 获取项的键     |
| config\['DATE']['date'] | 字符串       | 获取项的值     |

```python
import configparser

config = configparser.ConfigParser()
config.read('f:\config.ini')
print(config.sections())
print(config.items('DATE'))
print(config.options('DATE'))
print(config['DATE']['date'])
print(type(config['DATE']['date']))
```

## 写入 config.ini

```python
if not self.config.has_option("var", "key"):  # 检查是否存在该 key
    self.config.set("equation", self.com.get(), "") # 写入键和 key
    self.config.write(open('config.ini','w')) # 写入文件
```





# import schedule

## 任务计划

| 语法                                                 | 作用                         |
| ---------------------------------------------------- | ---------------------------- |
| schedule.every(10).minutes.do(函数,参数)             | 每隔十分钟执行一次任务       |
| schedule.every().hour.do(函数,参数)                  | 每隔一小时执行一次任务       |
| schedule.every().day.at("10:30:").do(函数,参数)      | 每天的 10:30 执行一次任务    |
| schedule.every(5).to(10).days.do(函数,参数)          | 每隔 5 到 10 天执行一次任务  |
| schedule.every().monday.do(函数,参数)                | 每周一的这个时候执行一次任务 |
| schedule.every().wednesday.at("13:15").do(函数,参数) | 每周三 13:15 执行一次任务    |
| schedule.run_pending()                               | 运行所有可以运行的任务       |

```python
import schedule
import time
 
def fun():
    print('demo')
 
schedule.every(0.01).minutes.do(fun)
schedule.every().hour.do(fun)
schedule.every().day.at("22:43:50").do(fun)
schedule.every(5).to(10).days.do(fun)
schedule.every().monday.do(fun)
schedule.every().wednesday.at("13:15").do(fun)
 
while True:
    time.sleep(1)
    schedule.run_pending()
```

# import socket

## 服务端套接字

| 参数               | 作用                  |
| ------------------ | --------------------- |
| socket.SOCK_STREAM | TCP                   |
| socket.SOCK_DGRAM  | UDP                   |
| AF_INET            | 服务器之间的通讯      |
| AF_INET6           | 服务器之间的通讯      |
| AF_UNIX            | UNIX 不同进程间的通讯 |

| 语法                                                         | 作用                       |
| ------------------------------------------------------------ | -------------------------- |
| serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) | 创建 socket 对象           |
| host = socket.gethostname()                                  | 获取本地主机名             |
| port = 9999<br>serversocket.bind((host, port))               | 绑定端口号                 |
| serversocket.listen(5)                                       | 设置最大连接数，超过后排队 |
| clientsocket, addr = serversocket.accept()                   | 建立客户端连接             |
| clientsocket.send(msg.encode('utf-8'))                       | 发送消息                   |
| clientsocket.send(bytes(msg,'utf-8'))                        | 发送消息                   |
| clientsocket.close()                                         | 关闭套接字                 |

```python
import socket

serversocket = socket.socket(
    socket.AF_INET, socket.SOCK_STREAM)

host = socket.gethostname()
port = 9999
serversocket.bind((host, port))

serversocket.listen(5)

while True:
    clientsocket, addr = serversocket.accept()
    msg = 'demo' + "\r\n"
    print(msg.encode('utf-8'))
    print(bytes(msg,'utf-8'))
    clientsocket.send(msg.encode('utf-8'))
    clientsocket.close()
```

## 客户端套接字

| 语法                                                  | 作用                     |
| ----------------------------------------------------- | ------------------------ |
| s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) | 创建 socket 对象         |
| host = socket.gethostname()                           | 获取本地主机名           |
| port = 9999                                           | 设置端口号               |
| s.connect((host, port))                               | 连接服务，指定主机和端口 |
| msg = s.recv(1024)                                    | 接收小于 1024 字节的数据 |
| print(msg.decode('utf-8'))                            | 打印接收消息             |
| print(str(msg,'utf-8'))                               | 接收消息                 |
| s.close                                               | 关闭套接字               |

```python
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

host = socket.gethostname()
port = 9999
s.connect((host, port))

msg = s.recv(1024)

s.close()

print (msg.decode('utf-8'))
print(str(msg,'utf-8'))
```

## 公告用途的套接字函数

| 语法            | 返回值        | 作用                     |
| --------------- | ------------- | ------------------------ |
| s.recv()        |               | 接收 TCP 数据            |
| s.send()        |               | 发送 TCP 数据            |
| s.sendall()     |               | 完整发送 TCP 数据        |
| s.recvfrom()    | (数据,地址)   | 接收 UDP 数据            |
| s.close()       |               | 关闭套接字               |
| s.getpeername() | (ipaddr,port) | 返回链接套接字的远程地址 |
| s.getsockname() | (ipaddr,port) | 返回套接字自己的地址     |

## 参考

https://www.runoob.com/python3/python3-socket.html

# import subprocess

```python
import subprocess
subprocess.Popen(args,bufsize=0,executable=None,stdin=None,stdout=None,stderr=None,preexec_fn=None,close_fds=False,shell=False,cwd=None,env=None,universal_newlines=False,startupinfo=None,creationflags=0)
```

| 语法            | 做用           |
| --------------- | -------------- |
| args            | 字符串或者列表 |
| subprocess.PIPE | 初始化参数     |

````python
import subprocess
subprocess.call('demo.bat', shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
````

# import pillow

| 语法                         | 作用               |
| ---------------------------- | ------------------ |
| imload = Image.open('1.jpg') | 打开图片           |
| im = imload.convert("RGB")   | 转换为 RGB 模式    |
| demo = open('rgb.txt','a')   | 追加方式写入到文件 |
| rgb = im.getpixel((x,y))     | 获取对应像素点的   |
| demo.write(rgb[1:-1]+"\t")   | 把 RGB值写入文件   |

## 图像转 excel

```python
from PIL import Image
imload = Image.open('1.jpg')
im = imload.convert("RGB")
width,height = im.size
demo = open('rgb.txt','a')

for y in range(height):
    for x in range(width):
        rgb = im.getpixel((x,y))
        rgb = str(rgb)
        demo.write(rgb[1:-1]+"\t")
    demo.write("\n")
demo.close()
```

VBA 渲染 RBG 颜色

| 语法                       | 作用           |
| -------------------------- | -------------- |
| For Each r In Range("A:B") | 渲染几列单元格 |

```vb
Sub code()
    Dim r As Range, arr
    For Each r In Range("A:A")
        arr = Split(r, ",")
        r.Interior.Color = RGB(CInt(arr(0)), CInt(arr(1)), CInt(arr(2)))
    Next
End Sub
```

# import sympy

2 * x = 6

3 * y = 18

```python
import sympy

x,y = sympy.symbols('x y')
z = sympy.Symbol('z')
demo = sympy.solve([2*x-6,3*y-18],[x,y])

print(demo[x],demo[y])
```
