---
layout:     post
title:      Python 模块
date:       2019-9-12
author:     Tangle
catalog: true
tags:
    - Python
---

# 模块导入

| 语法                                         | 作用                                     | 注意                         |
| -------------------------------------------- | ---------------------------------------- | ---------------------------- |
| `improt 文件名,文件名`                         | 导入单个或多个模块                       |                              |
| `from 文件名 import 函数名,函数名`             | 导入单个模块的单个函数或多个函数         |                              |
| `from 文件名 import *`                         | 导入模块内所有函数和变量                 |                              |
| `import 顶层包.子包.文件名`                    | 导入包中的单个模块，用包全称调用         | 包中必须有 `__init__.py` 文件 |
| `from 顶层包.子包 import 文件名,文件名`        | 导入包中的单个或多个模块，用文件名调用   | 包中必须有 `__init__.py` 文件 |
| `from 顶层包.子包.文件名 import 函数名,函数名` | 导入包中的单个或多个函数，用函数调用     | 包中必须有 `__init__.py` 文件 |

# time

四种类型

| 类型       | 类型   | 作用                                                       |
| :--------- | :----- | :--------------------------------------------------------- |
| 时间戳     | 浮点型 | 时间戳表示的是从 1970年1月1日 00:00:00 开始按秒计算的偏移量   |
| 结构化     | 元组   | 共有 9个元素组                                              |
| 格式化时间 | 字符串 | 已格式化的结构使时间更具可读性  包括自定义格式和固定格式   |
| 延时       | 无     | 延时                                                       |

## 时间戳

| 语法          | 作用            |
| :------------ | :-------------- |
| `time.time()`   | 本地时间        |
| `time.clock()`  | 计算CPU运行时间 |
| `time.mktime()` | 本地结构化时间  |

## 结构化时间

| 语法             | 作用           |
| :--------------- | :------------- |
| `time.gmtime()`    | UTC结构化时间  |
| `time.localtime()` | 本地结构化时间 |

结构化属性

| 索引 | 属性                      | 值                 |
| :--- | :------------------------ | :----------------- |
| 0    | tm_year（年）             | 2017               |
| 1    | tm_mon（月）              | 1-12               |
| 2    | tm_mday（日）             | 1-31               |
| 3    | tm_hour（时）             | 0-23               |
| 4    | tm_min（分）              | 0-59               |
| 5    | tm_sec（秒）              | 0-61(60或61是润秒) |
| 6    | tm_wday（一周中的第几天） | 0-6（0表示周一）   |
| 7    | tm_yday（一年中的第几天） | 1-366              |
| 8    | tm_isdst（是否是夏令时）  | 默认为0            |

结构化取单个值的两种方法

| 方法 | 作用       |
| :--- | :--------- |
| 1    | 变量.属性  |
| 2    | 变量[索引] |

## 格式化时间

| 语法                      | 作用                                   |
| :------------------------ | :------------------------------------- |
| `time.strftime('%Y-%m-%d')` | 本地格式化时间                         |
| `time.ctime(秒)`            | 本地固定格式时间，添加参数从1970年计时 |
| `time.asctime(结构化时间)`  | 本地固定格式时间                       |

格式化符号

| 符号 | 作用                                      |
| :--- | :---------------------------------------- |
| %Y   | 四位数的年份表示（000-9999）              |
| %m   | 月份（01-12）                             |
| %d   | 日（0-31）                                |
| %H   | 24小时制小时数（0-23）                    |
| %M   | 分钟数（00=59）                           |
| %S   | 秒（00-59）                               |
| %c   | 简化格式化时间                            |
| %x   | 本地相应的日期表示，用/分割               |
| %X   | 本地相应的时间表示，用:分割               |
| %B   | 本地完整的月份名称                        |
| %b   | 本地简化的月份名称                        |
| %A   | 本地完整星期名称                          |
| %a   | 本地简化星期名称                          |
| %j   | 年内的第几天（001-366）                   |
| %p   | 本地AM或PM的等价符，12或24小时制          |
| %U   | 一年中的星期数（00-53）星期天为星期的开始 |
| %w   | 星期（0-6），星期天为星期的开始           |
| %W   | 一年中的星期数（00-53）星期一为星期的开始 |
| %Z   | 当前时区的名称                            |
| %%   | %号本身                                   |
| %y   | 两位数的年份表示（00-99）                 |
| %I   | 12小时制小时数（01-12）                   |

## 种类转换

| 语法                                   | 作用                             |
| :------------------------------------- | :------------------------------- |
| time.strptime('2018-12-17','%Y-%m-%d') | 格式化时间转换结构化时间         |
| time.strftime('%Y-%m-%d',结构化时间)   | 结构化时间转换格式化时间         |
| time.localtime(秒)                     | 时间戳转换结构化时间             |
| time.ctime(秒)                         | 时间戳转换固定格式格式化时间     |
| time.asctime(结构化时间)               | 结构化时间转换固定格式格式化时间 |
| time.mktime(格式化时间)                | 结构化转时间戳                   |

# datetime

## datetime.datetime.now

```python
""" 本地格式化时间 """
datetime.datetime.now() # 2018-12-16 16:45:20.194687
```

# random

## random

```python
""" 0至1浮点型随机数 """
random.random() # 0.3137125524227292
```

## randint

```python
""" 1至8整数型随机数 """
random.randint(1,8) # 2
```

## chonice

```python
""" 随机打印单个 """
random.choices('hello') # ['e']
```

## sample

```python
""" 随机打印几个元素可调节 """
random.sample(['a','b','c'],1) # ['c']
```

## randrange

```python
""" 1至2随机数可调节 """
random.randrange(1,3) # 2
```

# os

## 切换当前工作路径

```
os.chdir(r"C:\Users\") # 切换当前工作路径
```

## 查看当前路径及路径下的文件

| 语法            | 返回值 | 作用                 |
| --------------- | ------ | -------------------- |
| os.getcwd()     | str    | 查看当前目录         |
| os.listdir('.') | list   | 查看当前目录所有文件 |

## 查看绝对路径

| 语法                 | 作用         |
| -------------------- | ------------ |
| os.path.abspath('.') | 返回绝对路径 |

## 查看路径文件夹和文件名

| 语法                                    | 返回值 | 作用                               |
| --------------------------------------- | ------ | ---------------------------------- |
| `os.path.split('F:\Easy Love\1.py')`    | 元组   | 将路径分解为文件夹和文件名         |
| `os.path.join('F:\Easy Love','666')`     |        | 拼接路径                           |
| `os.path.dirname('F:\Easy Love\1.py')`  |        | 返回路径中的文件夹部分结尾不包括\  |
| `os.path.basename('F:\Easy Love\1.py')` |        | 返回路径中的文件名                 |

## 查看文件时间

| 语法                                    | 返回值 | 作用                       |
| --------------------------------------- | ------ | -------------------------- |
| `os.path.getmtime('F:\Easy Love\1.py')` | 时间戳 | 文件或文件夹的最后修改时间 |
| `os.path.getatime('F:\Easy Love\1.py')` | 时间戳 | 文件或文件夹的最后访问时间 |
| `os.path.getctime('F:\Easy Love\1.py')` | 时间戳 | 文件或文件夹的创建时间     |

## 查看文件大小

| 语法                                   | 作用                                            |
| -------------------------------------- | ----------------------------------------------- |
| `os.path.getsize('F:\Easy Love\1.py')` | 文件或文件夹的大小，若是文件夹返回0，字节类型   |

## 查看文件是否存在

| 语法                                  | 返回值        | 作用             |
| ------------------------------------- | ------------- | ---------------- |
| `os.path.exists('F:\Easy Love\1.py')` | True \| False | 查看文件是否存在 |

## 一些表现形式参数

| 语法       | 作用      |
| ---------- | --------- |
| os.sep     | 表示 `\\`  |
| os.extsep  | 表示 .    |
| os.linesep | 表示 `\r\n` |

# sys

## sys.argv

实现从程序外部向程序传递参数

## sys.exit

退出程序，正常退出时exit(0)

## sys.path

返回模块的搜索路径，初始化使用Python环境变量的值

## sys.modules

是一个全局字典，该字典是python启动后就加载在内存中，每当程序员导入新的模块，sys.modules将自动记录该模块，当第二次再导入该模块时，python会直接到字典中查找,从而加快了程序运行的速度，它拥有字典所拥有的一切方法

## sys.platform

返回操作系统平台名称

# hashlib

## md5

```python
""" md5 加密 """
m = hashlib.md5()
m.update(b'hello')                                                     # b 代表字符串就是 bytes
b=m.update(b'world')                                                   # 等价于 (b'helloworld')
print(m.digest())    # b'\xfc^\x03\x8d8\xa5p2\x08TA\xe7\xfep\x10\xb0'  # 2进制格式 hash
print(m.hexdigest()) # fc5e038d38a57032085441e7fe7010b0# 16进制格式hash
```

## sha1

```python
""" sha1 加密 """
hash = hashlib.sha1()
hash.update(b'admin')
print(hash.hexdigest())
```

# logging

## logging.getLogger

创建记录器，参数日志名称

## logging.StreamHandler

创建屏幕打印，参数为空

## logging.FileHandler

创建写入文件，参数文件名称

## logging.Formatter

| 日志格式            | 作用                                                         |
| :------------------ | :----------------------------------------------------------- |
| %(name)s            | Logger的名字                                                 |
| %(levelno)s         | 数字形式的日志级别                                           |
| %(levelname)s       | 文本形式的日志级别                                           |
| %(pathname)s        | 调用日志输出函数的模块的完整路径名，可能没有                 |
| %(filename)s        | 调用日志输出函数的模块的文件名                               |
| %(module)s          | 调用日志输出函数的模块名                                     |
| %(funcName)s        | 调用日志输出函数的函数名                                     |
| %(lineno)d          | 调用日志输出函数的语句所在的代码行                           |
| %(created)f         | 当前时间，用UNIX标准的表示时间的浮点数表示                   |
| %(relativeCreated)d | 输出日志信息时的，自Logger创建以来的毫秒数                   |
| %(asctime)s         | 字符串形式的当前时间，默认格式是'2003-07-08 16:49:45,896'逗号后面的是毫秒 |
| %(thread)d          | 线程ID，可能没有                                             |
| %(threadName)s      | 线程名，可能没有                                             |
| %(process)d         | 进程ID，可能没有                                             |
| %(message)s         | 用户输出的消息                                               |

## setFormatter

给屏幕打印和文件写入添加日志格式

## addHandler

将屏幕打印和文件写入添加到记录器中

## 日志等级

```python
debug('')    # 调试
info('')     # 信息
warn('')     # 警告
erroe('')    # 错误
critical('') # 严重
```

日志记录器

```python
""" 日志记录器 """
import logging
logger = logging.getLogger('TEST-LOG')                                                # 创建记录器,参数写日志名
logger.setLevel(logging.DEBUG)                                                        # 日志等级
ch = logging.StreamHandler()                                                          # 屏幕打印
ch.setLevel(logging.DEBUG)                                                            # 日志等级
fh = logging.FileHandler("access.log")                                                # 文件写入,参数写文件名
fh.setLevel(logging.DEBUG)                                                            # 日志等级
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') # 创建日志格式
ch.setFormatter(formatter)                                                            # 将日志格式添加到ch
fh.setFormatter(formatter)                                                            # 将日志格式添加到fh
logger.addHandler(ch)                                                                 # 将ch屏幕打印添加到记录器
logger.addHandler(fh)                                                                 # 将fh文件写入添加到记录器
logger.debug('debug message')                                                         # 日志记录
logger.info('info message')                                                           # 日志记录
logger.warn('warn message')                                                           # 日志记录
logger.error('error message')                                                         # 日志记录
logger.critical('critical message')                                                   # 日志记录
```

# 正则表达式

根据条件匹配，条件匹配结束后内容没有匹配完，反复使用条件匹配直到所有内容匹配完为止。

## 元字符

```
.     # 除\n代表任意字符
^     # 只能从头开始匹配
$     # 只能从结尾开始匹配
+     # 前的一个字符 1 至 n 次匹配
*     # 字符串前端能匹配几个是几个，全匹上前一个字符 0 至 n 次匹配
{1,2} # 前的一个字符匹配1个或2个字符串，直到匹配结束
?     # 只能匹配0次或1次
[^]   # 取反
\|    # 匹配到其中一个就可以
()    # 只显示分组内的匹配
(?:)  # 分组有权限用 ?: 去除就可以全部显示了

\d    # 匹配任意数字，同 [0-9]
\D    # 匹配非数字，同 [^0-9]
\s    # 匹配任何空白字符，同 [ \t\n\r\f\v]
\S    # 匹配非空白字符，同 [^\s]
\w    # 匹配包括下划线在内的任何字母数字，同 [a-zA-Z0-9_]
\W    # 匹配特殊字符，同 [^a-zA-Z0-9_]
\b    # 匹配一个有特殊字符边界的字符,比如空格、&、#
\B    # 匹配一个没有特殊字符边界的字符，比如空格、&、#
\A    # 仅匹配字符串开头，同 ^
\Z    # 仅匹配字符串的结尾，同 $
```

## findall

```python
""" 元字符，所有结果都返回一个列表内 """
re.findall('h..lo','hello world')        # ['hello']            # .除\n代表任意字符
re.findall('^hello','hello world')       # ['hello']            # ^只能从头开始匹配
re.findall('hello$','hello world')       # []                   # $只能从结尾开始匹配
re.findall('hello+','hellooo world')     # ['hellooo']          # +前的一个字符1至∞次匹配
re.findall('helo*','hellooo world')      # ['hel']              # *字符串前端能匹配几个是几个，全匹上前一个字符0至∞次匹配
re.findall('hello{1,2}','hellooo world') # ['helloo']           # {1,2}前的一个字符匹配2次，可调节
re.findall('a?b?c', 'aac')               # ['ac']               # ?只能匹配0次或1次
re.findall('a[^\d]d','acd')              # ['acd']              # [^]取反
re.findall('a|b','aabb')                 # ['a', 'a', 'b', 'b'] # |匹配到其中一个就可以
re.findall('123(ab)','123abc')           # ['ab']               # ()只显示分组内的匹配
re.findall('123(?:ab)','123abc')         # ['123ab']            # (?:)分组有权限用?:去除就可以全部显示了
```

## search

返回匹配到的一个对象，可以调用以下方法返回结果

| 语法    | 返回类型 | 作用                                   |
| :------ | :------- | :------------------------------------- |
| group() | str      | 返回被 re 匹配到的字符串。             |
| start() | int      | 返回匹配开始的位置。                   |
| end()   | int      | 返回匹配结束的位置。                   |
| span()  | tuple    | 返回一个元组，包含匹配开始结束的位置。 |

```python
a=re.search('(?P<id>\d{2})|(?P<name>\w{3})','2/com')         # (?p<>)是分组命名格式，|是或的意识
a.group()                                            # 'com' # 调用search中匹配到的字符
a.group('id')                                                # 调用名字为id分组匹配结果
a.group('name')                                      # 'com' # 调用名字为name分组匹配的结果
```

## match

只在字符串开始匹配,返回一个对象，对象可以调用group，返回结果

```python
obj = re.compile(r'www.*.com') # 创建规则对象
b = a.match('www.baidu.com')   # 现在 b 就是一个对象
print(b)                       # <_sre.SRE_Match object; span=(1, 14), match='www.baidu.com'>
```

## split

分割字符串

```python
re.split('cd','abcdef')   # ['ab', 'ef']     # 用 cd 分割
re.split('[cd]','abcdef') # ['ab', '', 'ef'] # 先用 c 分割再用 d 分割
```

## sub

修改字符串

```python
re.sub('a','b','aaaaa'1,3)  # 'bbbaa' # 3是个数参数，默认为全部修改
re.subn('a','b','aaaaa',10)           # 10是个数参数，默认为全部修改
```

## compole

创建的compole规则对象可以用re其他方法调用

```python
object=re.compile(r'www.*.com')                       # 创建规则对象
object.findall('aaawww.bbb.comccc') # ['www.bbb.com'] # 用规则对象进行匹配
```

## findtier

返回的是一个迭代器

```python
import re
b=re.finditer('\d','1a2b3c')
a=0
while True:
    if a<3:
        print(next(b).group()) # 1 2 3
        a+=1
    else:
        break
```

# 序列化

## json

我们把对象(变量)从内存中变成可储存或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也称之为serialization、marshalling、flattening等等，都是一个意识。

序列化之后就可以把序列化后的内容写入磁盘，或者通过网络传输到其他机器上反之，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling

如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的办法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便存储到磁盘或者通过网络传输JSON不仅是标注格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便

### 序列化

```python
import json
dic={'name':'tangle','age':23,'sex':'male'}
print(type(dic)) # <class 'dict'>
j=json.dumps(dic)
print(type(j))   # <class 'str'>
f=open('序列化对象','w')
f.write(j)       # 或 json.dump(dic,f)
f.close()
```

### 反序列化

```python
import json
f = open('序列化对象')
data = json.loads(f.read()) # 或 data=json.load(f)
print(data)
f.close
```

## pickle

### 序列化

```python
import pickle
dic = {'name': 'tangle', 'age': 23, 'sex': 'male'}
print(type(dic))            # <class 'dict'>
j = pickle.dumps(dic)
print(type(j))              # <class 'bytes'>
f = open('序列化对象', 'wb') # w是写入str，wb是写入bytes，j是bytes类型
f.write(j)                  # 等价于 pickle.dump(dic,f)
f.close()
```

### 反序列化

```python
import pickle
f = open('序列化对象', 'rb')
data = pickle.loads(f.read()) # 等价于 data=pickle.load(f)
print(data['age'])
```

## shelve

shelve 模块比 pickle 模块简单，只有一个 open 函数，返回类似字典的对象，可读可写，key 必须为字符串，而值可以是 Python 所有支持的数据类型

### 序列化

```python
import shelve
f= shelve.open(r'shelve.txt')            # 打开文件
f['info_1']={'name':'tangle','age':'18'} # 写入文件
f['info_1']={'name':'python','age':'27'}
f.close()
```

### 反序列化

```python
import shelve
f = shelve.open(r'shelve.txt')    # 打开文件
print(f.get('stu1_info')['age'] ) # 18
data=f.get('school_info')
print(data)                       # {'website': 'oldboyedu.com', 'city': 'beijing'}
```

# win32

## 窗口

| 语法                                                 | 输出          | 作用                         |
| ---------------------------------------------------- | ------------- | ---------------------------- |
| win32api.GetSystemMetrics(win32con.SM_CXSCREEN)      | 宽度分辨率    | 获取宽度分辨率               |
| win32api.GetSystemMetrics(win32con.SM_CYSCREEN)      | 高度分辨率    | 获取高度分辨率               |
| left,top,right,bottom = win32gui.GetWindowRect(句柄) | (左,上,右,下) | 获取窗口左上角和右下角坐标   |
| win32gui.PostMessage(hwnd, win32con.WM_CLOSE,0,0)    |               | 关闭窗口                     |
| win32gui.SetForegroundWindow(hwnd)                   |               | 设置为前台                   |
| win32gui.SetForegroundWindow(句柄)                   |               | 窗口置顶                     |

| 语法                                         | 参数               | 做用                                                       |
| -------------------------------------------- | ------------------ | ---------------------------------------------------------- |
| win32gui.ShowWindow(句柄, win32con. SW_HIDE) | SW_HIDE            | 隐藏窗口，大小不变，激活状态不变                           |
|                                              | SW_MAXIMIZE        | 最大化窗口，显示状态不变，激活状态不变                     |
|                                              | SW_MINIMIZE        | 最小化窗口，显示状态不变，激活状态不变                     |
|                                              | SW_RESTORE         | 从最大化或最小化恢复正常大小，显示状态不变，激活状态不变   |
|                                              | SW_SHOW            | 显示并激活窗口，大小状态不变                               |
|                                              | SW_SHOWMAXIMIZED   | 显示并激活窗口，以最大化显示                               |
|                                              | SW_SHOWMINIMIZED   | 显示并激活窗口，以最小化显示                               |
|                                              | SW_SHOWMINNOACTIVE | 显示窗口并最小化，激活状态不变                             |
|                                              | SW_SHOWNA          | 显示窗口，大小状态不变，激活状态不变                       |
|                                              | SW_SHOWNOACTIVATE  | 显示并从最大化或最小化恢复正常大小，激活状态不变           |
|                                              | SW_SHOWNORMAL      | 显示并激活窗口，恢复正常大小                               |

## 句柄

| 语法                                                         | 输出                    | 作用                                                 |
| ------------------------------------------------------------ | ----------------------- | ---------------------------------------------------- |
| win32gui.FindWindow('类名', '窗口标题')                      | 句柄                    | 通过类名标题获取窗口句柄，类名不知道可以填写 0       |
| win32gui.GetWindowRect(句柄)                                 | (x坐标,y坐标,宽度,高度) | 返还窗口信息元祖类型                                 |
| win32gui.FindWindowEx(句柄, None, 类名, 窗口标题)            | 句柄                    | 通过父句柄获取子句柄                                 |
| hwndChildList = []<br>win32gui.EnumChildWindows(句柄, lambda hwnd, param: param.append(hwnd),hwndChildList) |                         | 根据句柄列出子句柄，如果句柄为 None 列出所有主句柄   |

## 鼠标

| 语法                                                         | 输出           | 作用             |
| ------------------------------------------------------------ | -------------- | ---------------- |
| win32api.GetCursorPos()                                      | (x坐标, y坐标) | 获取鼠标坐标。   |
| win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,0,0,0,0)  |                | 鼠标左键按下     |
| win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,0,0,0,0)    |                | 鼠标左键弹起     |
| win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTDOWN,0,0,0,0) |                | 鼠标右键按下     |
| win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP,0,0,0,0)   |                | 鼠标右键弹起     |
| win32api.SetCursorPos((x, y))                                |                | 设置鼠标位置     |
| win32api.SendMessage(句柄,win32con.WM_LBUTTONDOWN,win32con.MK_LBUTTON,win32api.MAKELONG(x坐标,y坐标)) |                | 后台鼠标左键按下 |
| win32api.SendMessage(句柄,win32con.WM_LBUTTONUP,win32con.MK_LBUTTON,win32api.MAKELONG(x坐标,y坐标)) |                | 后台鼠标左键弹起 |

## 键盘

| 语法                                  | 作用     |
| ------------------------------------- | -------- |
| win32gui.SetForegroundWindow(0)       | 绑定窗口 |
| win32api.keybd_event(键代码, 0, 0, 0) | 按下     |
| win32api.keybd_event(键代码, 0, 0, 0) | 弹起     |

## 根据句柄获取句柄标题和类名

| 语法                                  | 输出 | 作用     |
| ------------------------------------- | ---- | -------- |
| title = win32gui.GetWindowText(句柄)  | 标题 | 获取标题 |
| clsname = win32gui.GetClassName(句柄) | 类名 | 获取类名 |

## 菜单

| 语法                                                       | 作用                |
| ---------------------------------------------------------- | ------------------- |
| menu = win32gui.GetMenu(句柄)                              | 获取第几个主菜单    |
| menu1 = win32gui.GetSubMenu(menu, 0)                       | 获取第几个主菜单    |
| cmd_ID = win32gui.GetMenuItemID(menu1, 2)                  | 获取第几个子菜单 ID |
| win32gui.PostMessage(句柄, win32con.WM_COMMAND, cmd_ID, 0) | 点击菜单            |

```python
import win32con
import win32gui

hwnd = win32gui.FindWindow('SciCalc','计算器')
menu = win32gui.GetMenu(hwnd)
menu1 = win32gui.GetSubMenu(menu, 0)
cmd_ID = win32gui.GetMenuItemID(menu1, 1)
win32gui.PostMessage(hwnd, win32con.WM_COMMAND, cmd_ID, 0)

def get_menu_item_txt(menu,idx):
    import win32gui_struct

    mii, extra = win32gui_struct.EmptyMENUITEMINFO()           # 新建一个win32gui的空的结构体mii
    win32gui.GetMenuItemInfo(menu, idx, True, mii)             # 将子菜单内容获取到mii
    ftype, fstate, wid, hsubmenu, hbmpchecked, hbmpunchecked,\ # 解包mii
    dwitemdata, text, hbmpitem = win32gui_struct.UnpackMENUITEMINFO(mii)
    return text

for i in range(3):
    print(get_menu_item_txt(menu,i))

for i in range(2):
    print(get_menu_item_txt(menu1,i))
```

# threading

```
t = threading.Thread(target = function, args = (arg, arg)) # 创建线程
t.start()                                                  # 执行线程调用创建线程中的函数
t.setDaemon(True)                                          # 每个线程设置此方法，主线程结束子线程也结束
threading.active_count()                                   # 查看当前运行多少个线程
t.join()                                                   # 等待线程结束
```

```python
import threading

def test():
    while True:
        if not ev1.wait(): break

ev1 = threading.Event()
ev1.set()

t = threading.Thread(target = test)
t.start()

ev1.clear()
```

## 线程锁

禁止 cpu 切换，锁中的代码串行运行

```python
r = threading.Lock()
r.acquire()
print('demo')
r.release()
```

可重用锁

```python
r = threading.RLock()
r.acquire()
print('demo')
r.release()
```

信号量

```python
semaphore=threading.BoundedSemaphore(5)
r.acquire()
print('demo')
r.release()
```

# configparser

## 创建 config.ini

| 语法                                    | 作用     |
| --------------------------------------- | -------- |
| config = configparser.ConfigParser()    | 实例化   |
| config['DATE'] = {'date': '2019-05-08'} | 设置配置 |

```python
import configparser

config = configparser.ConfigParser() # 注意大小写
config['DATE'] = {'date': '2019-05-08'}

with open('f:\config.ini', 'w') as configfile:
    config.write(configfile)
```

## 读取 config.ini

| 语法                    | 返回值       | 作用           |
| ----------------------- | ------------ | -------------- |
| config.sections()       | 列表         | 获取所有项     |
| config.items('DATE')    | 列表嵌套元组 | 获取项的键和值 |
| config.options('DATE')  | 列表         | 获取项的键     |
| config\['DATE']['date'] | 字符串       | 获取项的值     |

```python
import configparser

config = configparser.ConfigParser()
config.read('f:\config.ini')
print(config.sections())
print(config.items('DATE'))
print(config.options('DATE'))
print(config['DATE']['date'])
print(type(config['DATE']['date']))
```

## 写入 config.ini

```python
if not self.config.has_option("var", "key"):        # 检查是否存在该 key
    self.config.set("equation", self.com.get(), "") # 写入键和 key
    self.config.write(open('config.ini','w'))       # 写入文件
```





# schedule

## 任务计划

| 语法                                                 | 作用                         |
| ---------------------------------------------------- | ---------------------------- |
| schedule.every(10).minutes.do(函数,参数)             | 每隔十分钟执行一次任务       |
| schedule.every().hour.do(函数,参数)                  | 每隔一小时执行一次任务       |
| schedule.every().day.at("10:30:").do(函数,参数)      | 每天的 10:30 执行一次任务    |
| schedule.every(5).to(10).days.do(函数,参数)          | 每隔 5 到 10 天执行一次任务  |
| schedule.every().monday.do(函数,参数)                | 每周一的这个时候执行一次任务 |
| schedule.every().wednesday.at("13:15").do(函数,参数) | 每周三 13:15 执行一次任务    |
| schedule.run_pending()                               | 运行所有可以运行的任务       |

```python
import schedule
import time

def fun():
    print('demo')

schedule.every(0.01).minutes.do(fun)
schedule.every().hour.do(fun)
schedule.every().day.at("22:43:50").do(fun)
schedule.every(5).to(10).days.do(fun)
schedule.every().monday.do(fun)
schedule.every().wednesday.at("13:15").do(fun)

while True:
    time.sleep(1)
    schedule.run_pending()
```

# socket

## 服务端套接字

| 参数               | 作用                  |
| ------------------ | --------------------- |
| socket.SOCK_STREAM | TCP                   |
| socket.SOCK_DGRAM  | UDP                   |
| AF_INET            | 服务器之间的通讯      |
| AF_INET6           | 服务器之间的通讯      |
| AF_UNIX            | UNIX 不同进程间的通讯 |

| 语法                                                         | 作用                       |
| ------------------------------------------------------------ | -------------------------- |
| serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) | 创建 socket 对象           |
| host = socket.gethostname()                                  | 获取本地主机名             |
| port = 9999<br>serversocket.bind((host, port))               | 绑定端口号                 |
| serversocket.listen(5)                                       | 设置最大连接数，超过后排队 |
| clientsocket, addr = serversocket.accept()                   | 建立客户端连接             |
| clientsocket.send(msg.encode('utf-8'))                       | 发送消息                   |
| clientsocket.send(bytes(msg,'utf-8'))                        | 发送消息                   |
| clientsocket.close()                                         | 关闭套接字                 |

```python
import socket

serversocket = socket.socket(
    socket.AF_INET, socket.SOCK_STREAM)

host = socket.gethostname()
port = 9999
serversocket.bind((host, port))

serversocket.listen(5)

while True:
    clientsocket, addr = serversocket.accept()
    msg = 'demo' + "\r\n"
    print(msg.encode('utf-8'))
    print(bytes(msg,'utf-8'))
    clientsocket.send(msg.encode('utf-8'))
    clientsocket.close()
```

## 客户端套接字

| 语法                                                  | 作用                     |
| ----------------------------------------------------- | ------------------------ |
| s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) | 创建 socket 对象         |
| host = socket.gethostname()                           | 获取本地主机名           |
| port = 9999                                           | 设置端口号               |
| s.connect((host, port))                               | 连接服务，指定主机和端口 |
| msg = s.recv(1024)                                    | 接收小于 1024 字节的数据 |
| print(msg.decode('utf-8'))                            | 打印接收消息             |
| print(str(msg,'utf-8'))                               | 接收消息                 |
| s.close                                               | 关闭套接字               |

```python
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

host = socket.gethostname()
port = 9999
s.connect((host, port))

msg = s.recv(1024)

s.close()

print (msg.decode('utf-8'))
print(str(msg,'utf-8'))
```

## 公告用途的套接字函数

| 语法            | 返回值        | 作用                     |
| --------------- | ------------- | ------------------------ |
| s.recv()        |               | 接收 TCP 数据            |
| s.send()        |               | 发送 TCP 数据            |
| s.sendall()     |               | 完整发送 TCP 数据        |
| s.recvfrom()    | (数据,地址)   | 接收 UDP 数据            |
| s.close()       |               | 关闭套接字               |
| s.getpeername() | (ipaddr,port) | 返回链接套接字的远程地址 |
| s.getsockname() | (ipaddr,port) | 返回套接字自己的地址     |

## 参考

https://www.runoob.com/python3/python3-socket.html

# subprocess

```python
import subprocess
subprocess.Popen(args,bufsize=0,executable=None,stdin=None,stdout=None,stderr=None,preexec_fn=None,close_fds=False,shell=False,cwd=None,env=None,universal_newlines=False,startupinfo=None,creationflags=0)
```

| 语法            | 做用           |
| --------------- | -------------- |
| args            | 字符串或者列表 |
| subprocess.PIPE | 初始化参数     |

````python
import subprocess
subprocess.call('demo.bat', shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
````

# pillow

| 语法                         | 作用               |
| ---------------------------- | ------------------ |
| imload = Image.open('1.jpg') | 打开图片           |
| im = imload.convert("RGB")   | 转换为 RGB 模式    |
| demo = open('rgb.txt','a')   | 追加方式写入到文件 |
| rgb = im.getpixel((x,y))     | 获取对应像素点的   |
| demo.write(rgb[1:-1]+"\t")   | 把 RGB值写入文件   |

## 图像转 excel

```python
from PIL import Image
imload = Image.open('1.jpg')
im = imload.convert("RGB")
width,height = im.size
demo = open('rgb.txt','a')

for y in range(height):
    for x in range(width):
        rgb = im.getpixel((x,y))
        rgb = str(rgb)
        demo.write(rgb[1:-1]+"\t")
    demo.write("\n")
demo.close()
```

VBA 渲染 RBG 颜色

| 语法                       | 作用           |
| -------------------------- | -------------- |
| For Each r In Range("A:B") | 渲染几列单元格 |

```vb
Sub code()
    Dim r As Range, arr
    For Each r In Range("A:A")
        arr = Split(r, ",")
        r.Interior.Color = RGB(CInt(arr(0)), CInt(arr(1)), CInt(arr(2)))
    Next
End Sub
```

# sympy

2 * x = 6

3 * y = 18

```python
import sympy

x,y = sympy.symbols('x y')
z = sympy.Symbol('z')
demo = sympy.solve([2*x-6,3*y-18],[x,y])

print(demo[x],demo[y])
```

# matplotlib.pyplot

## 图例位置

```
import matplotlib.pyplot as plt
import numpy as np

x = np.arange(10)
fig = plt.figure()
ax = plt.subplot(111)

for i in range(5):
    ax.plot(x, i * x, label='$y = %ix$'%i)

box = ax.get_position()
ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
ax.legend(loc='upper left', bbox_to_anchor=(1, 1))

plt.show()
```

# efpython

## 常用

```
pip install cefpython3
```

```python
# coding=gbk
from cefpython3 import cefpython as cef
from flask import Flask
import ctypes
import tkinter as tk
import threading
import os

class Application(tk.Frame):
    navigation_bar = None
    def __init__(self, root):
        root.geometry("900x640")
        tk.Frame.__init__(self, root)
        self.master.title("")
        self.bind("<Configure>", self.on_configure)

        self.browser_frame = BrowserFrame(self, self.navigation_bar) # 浏览器框架
        self.browser_frame.grid(row=1, column=0,sticky=(tk.N + tk.S + tk.E + tk.W))
        tk.Grid.rowconfigure(self, 1, weight=1)
        tk.Grid.columnconfigure(self, 0, weight=1)
        self.pack(fill=tk.BOTH, expand=tk.YES)                       # 包装 Application

    def on_configure(self, event):
        if self.browser_frame:
            width = event.width
            height = event.height
            if self.navigation_bar:
                height = height - self.navigation_bar.winfo_height()
            self.browser_frame.on_Application_configure(width, height)

class BrowserFrame(tk.Frame):
    closing = False
    browser = None
    def __init__(self, master, navigation_bar=None):
        self.navigation_bar = navigation_bar
        tk.Frame.__init__(self, master)
        self.bind("<Configure>", self.on_configure)

    def embed_browser(self):
        window_info = cef.WindowInfo()
        rect = [0, 0, self.winfo_width(), self.winfo_height()]
        window_info.SetAsChild(self.get_window_handle(), rect)

        self.browser = cef.CreateBrowserSync(
            window_info,
            url="file://{}".format(os.path.join(os.getcwd(), 'handsontable.html'))
        )
        self.message_loop_work()

    def get_window_handle(self):                                     # 获取窗口句柄
        if self.winfo_id() > 0:
            return self.winfo_id()

    def message_loop_work(self):                                     # 消息循环工作
        cef.MessageLoopWork()
        self.after(10, self.message_loop_work)

    def on_configure(self, _):                                       # 判断是否有 cef 对象
        if not self.browser:
            self.embed_browser()

    def on_Application_configure(self, width, height):               # cef 窗口大小
        if self.browser:
            pass
            ctypes.windll.user32.SetWindowPos(self.browser.GetWindowHandle(),
                                              0,0, 0, width, height, 0x0002)
def runserver():
    app = Flask(__name__)
    @app.route('/')
    def index():
        return '<h1>233</h1>'
    app.run()

if __name__ == '__main__':
    threading.Thread(target=runserver).start()
    root = tk.Tk()
    app = Application(root)
    cef.Initialize()
    app.mainloop()
    cef.Shutdown()
    os._exit(0)
```

## 检查更新

| 语法                                                         | 返回值                   | 作用                             |
| ------------------------------------------------------------ | ------------------------ | -------------------------------- |
| ver["version"]                                               | 66.0                     | CEF Python 版本                  |
| ver["chrome_version"]                                        | 66.0.3359.181            | Chromium 版本                    |
| ver["cef_version"]                                           | CEF 3.3359.1774.gd49d25f | CEF 版本                         |
| ver=platform.python_version()<br>arch=platform.architecture()[0] | Python 3.6.5<br>64bit    | python 版本<br>位数              |
| assert cef.\__version__ >= "57.0", "CEF Python v57.0+ required to run this" |                          | CEF 版本是否大于 57 不大于抛异常 |

```python
from cefpython3 import cefpython as cef
import platform

ver = cef.GetVersion()
print("[hello_world.py] CEF Python {ver}".format(ver=ver["version"]))
print("[hello_world.py] Chromium {ver}".format(ver=ver["chrome_version"]))
print("[hello_world.py] CEF {ver}".format(ver=ver["cef_version"]))
print("[hello_world.py] Python {ver} {arch}".format(ver=platform.python_version(),arch=platform.architecture()[0]))
assert cef.__version__ >= "57.0", "CEF Python v57.0+ required to run this"
```

## 打包

```python
pip install pyinstaller
pip install pycrypto
python pyinstaller.py
```

0. 安装 Microsoft Visual C++ 14.0 选择 Windows 8.1 SDK 功能
0. 复制 C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\include\stdint.h
0. 粘贴 C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt
0. 修改 C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\inttypes.h

```
#include <stdint.h>
#include "stdint.h"
```

5、卸载 Micrsoft Visual C++ 14.0

# tkinter

| 语法               | 作用           |
| ------------------ | -------------- |
| `time = StringVar()` | 声明字符串钩子 |
| `time.set('1')`     | 设置初始值     |

```python
import tkinter as tk
from tkinter import messagebox
from tkinter import ttk

root = tk.Tk()
root.title('My root')
root.geometry('500x300')

def demo():
    pass

b1 = tk.Button(root, text='文本', font=('Arial', 12), width=10, height=1, command=demo)
b1.pack()

root.mainloop()
```

## 主窗口参数

| 语法                                                         | 作用                                             |
| ------------------------------------------------------------ | ------------------------------------------------ |
| `root = tk.TK()`                                               | 创建窗口                                         |
| `root['height'] = 300`                                         | 设置高                                           |
| `root['width'] = 500`                                          | 设置宽                                           |
| `root.title('魔方小站')`                                       | 设置标题                                         |
| `root['bg'] = '#0099ff'`                                       | 设置背景色                                       |
| `root.geometry("500x300+120+100")`                             | 设置窗口大小                                     |
| `root.option_add('*Font', 'Fira 10')`                          | 设置全局字体                                     |
| `root.resizable(width=False,height=True)`<br>`root.resizable(0,1)` | 禁止窗口调整大小                                 |
| `root.minsize(300,600)`                                        | 窗口可调整的最小值                               |
| `root.maxsize(600,1200)`                                       | 窗口可调整的最大值                               |
| `root.attributes("-toolwindow", 1)`                            | 工具栏样式                                       |
| `root.attributes("-topmost", -1)`                              | 置顶窗口                                         |
| `root.state("zoomed")`                                         | 窗口最大化                                       |
| `root.iconify()`                                               | 窗口最小化                                       |
| `root.attributes("-alpha",1)`                                  | 窗口透明化，透明度从 0-1，1 是不透明，0 是全透明 |
| `root.iconbitmap('c:\\logo.ico')`                              | 设置左上角图标                                   |
| `root.destroy()`                                               | 关闭窗口                                         |
| `root.mainloop()`                                              | 主窗口循环更新                                   |

## 窗口禁止关闭

``` python
def closeroot():
    messagebox.showerror(title='警告',message='没错你关不掉')
    return
root.protocol('WM_DELETE_root', closeroot)
```

正常退出

```python
def closewindow():
    quit()
root.protocol("WM_DELETE_WINDOW", closewindow)
```

##  Label 标签

| 语法                                                         | 作用     |
| ------------------------------------------------------------ | -------- |
| `l = tk.label(root,text = '文本',bg = '颜色',font = ('Arial',12),width = 30,height = 2)` | 创建标签 |
| `l.pack()`                                                     | 显示标签 |

## Button 按钮

| 语法                                                         | 作用       |
| ------------------------------------------------------------ | ---------- |
| `b = tk.Button(root, text='文本', font=('Arial', 12), width=10, height=1, command=函数名)` | 创建按钮   |
| `b.pack()`                                                     | 显示按钮   |

## Entry 输入框

| 语法                                               | 作用                               |
| -------------------------------------------------- | ---------------------------------- |
| `e1 = tk.Entry(root, show='*', font=('Arial', 14)`   | 创建输入框，密文显示               |
| `e1.pack()`                                          | 放置输入框                         |
| `e2 = tk.Entry(root, show=None, font=('Arial', 14))` | 创建输入框，明文显示               |
| `e2.pack()`                                          | 放置输入框                         |
| `e.get()`                                            | 输出输入框中的内容，可以作为变量   |

## Text 文本框

| 语法                            | 作用                        |
| ------------------------------- | --------------------------- |
| `text = tk.Text(root,height = 3)` | 创建文本框                  |
| `text.pack()`                     | 放置文本框                  |
| `text.insert('insert',文本)`      | 在文本框鼠标标点处插入      |
| `text.insert('end',文本)`         | 在文本框末尾处插入          |
| `text.mark_set('mark',1.0)`       | 1.0 或 1.1 设置标记插入位置 |
| `text.insert('mark',文本)`        | 在标记处插入                |
| `text.mark_gravity('mark',LEFT)`  | 标记在右侧插入              |

按钮改变文本

```
foo = StringVar()
foo.set("开")
def demo():
    foo.set("关")
按钮 = tk.Button(root,textvariable=foo,command=开始1)
按钮.grid(row=5, column=0, padx=10, pady=5)
```

## Listbox 窗口部件

列表框

| 语法                                | 作用                 |
| ----------------------------------- | -------------------- |
| `self.lb.curselection()`              | 提取点中选项的下标   |
| `self.lb.get(self.lb.curselection())` | 提前点中选项下标的值 |

## Radiobutton 窗口部件

单选框

## Checkbutton 窗口部件

复选框

## Scale 窗口部件

刻度条

## Canvas 窗口部件

画布

## Menu 窗口部件

| 语法                                                         | 作用                               |
| ------------------------------------------------------------ | ---------------------------------- |
| `菜单栏 = tk.Menu(root)`                                       | 创建一个菜单栏                     |
| `菜单项 = tk.Menu(菜单栏, tearoff=0)`                          | 创建一个菜单项，默认不下拉         |
| `菜单栏.add_cascade(label='菜单名', menu=菜单项)`              | 空菜单命名                         |
| `菜单项.add_command(label='子菜单名', command=函数名)`         | 在菜单项中加入子菜单               |
| `菜单项.add_separator()`                                       | 在菜单项中加入一条分割线           |
| `菜单项2 = tk.Menu(菜单栏, tearoff=0)`                         | 创建第二个菜单项,默认不下拉        |
| `菜单栏.add_cascade(label='菜单名', menu=菜单项2)`             | 空菜单命名                         |
| `菜单项2.add_command(label='子菜单名', command=函数名)`        | 在菜单项中加入子菜单               |
| `二级菜单 = tk.Menu(菜单项)`                                   | 创建二级菜单，即菜单项里面的菜单   |
| `菜单项.add_cascade(label='菜单名', menu=二级菜单, underline=0)` | 在菜单项下面创建一个菜单项         |
| `二级菜单.add_command(label='菜单名', command=函数名)`         | 创建第三级菜单命令                 |
| `root.config(menu=菜单栏)`                                     | 放置菜单栏                         |

## Combobox 下拉选择

| 语法                                      | 作用                 |
| ----------------------------------------- | -------------------- |
| `cv = tk.stringVar()`                       | 绑定变量             |
| `com = ttk.Combobox(root, textvariable=cv)` | 创建下拉框           |
| `com.pack()`                                | 放置下拉框           |
| `com["value"] = ('文本',文本')`             | 设置下拉数据         |
| `com.current(索引)`                         | 设置默认值           |
| `demo = com.get()`                          | 变量接受值           |
| `com.bind("<<ComboboxSelected>>", 函数名)`  | 下拉数据点击调用函数 |

## Frame 窗口部件

## messageBox 弹窗

| 语法                                                         | 作用         |
| ------------------------------------------------------------ | ------------ |
| `tk.messagebox.showwarning(title='窗口名', message='警告信息')` | 警告信息弹窗 |
| `tk.messagebox.showinfo('窗口名','提示信息')`                  | 提示信息弹窗 |
| `tk.messagebox.showerror('窗口名','错误信息')`                 | 错误信息弹窗 |

| 语法                                                   | 返回值        | 作用                 |
| ------------------------------------------------------ | ------------- | -------------------- |
| `tk.messagebox.askokcancel('提示','要执行此操作吗')`     | True \| False | (疑问)确定取消对话框 |
| `tk.messagebox.askquestion('提示', '要执行此操作吗')`    | yes \| no     | (疑问)是否对话框     |
| `tk.messagebox.askyesno('提示', '要执行此操作吗')`       | True \| False | (疑问)是否对话框     |
| `tk.messagebox.askretrycancel('提示', '要执行此操作吗')` | True \| False | (警告)重试取消对话框 |

| 语法                                 | 返回值         | 作用                         |
| ------------------------------------ | -------------- | ---------------------------- |
| `tk.filedialog.asksaveasfilename()`    | 含后缀文件目录 | 另存为窗口弹窗               |
| `tk.filedialog.asksaveasfile()`        | 文件流对象     | 另存为窗口弹窗，会创建文件   |
| `tkinter.filedialog.askopenfilename()` | 含后缀文件目录 | 打开文件弹窗                 |
| `tk.filedialog.askopenfile()`          | 文件流对象     | 打开文件弹窗                 |
| `tk.filedialog.askdirectory()`         | 目录名         | 选择文件弹窗                 |
| `tk.filedialog.askopenfilenames()`     | 元组           | 打开多个文件名               |
| `tk.filedialog.askopenfiles()`         | 列表           | 多个文件流对象               |

### 主窗口隐藏

```
from tkinter import messagebox
import tkinter as tk
tk.Tk().withdraw(); # 主窗口隐藏
messagebox.askokcancel('提示','要执行此操作吗')
```

## 部件放置方式

| 放置方式 | 参数      | 作用                             |
| -------- | --------- | -------------------------------- |
| grid     | row = 0   | 行                               |
|          | colum = 0 | 列                               |
|          | padx = 0  | 单元格左右间距                   |
|          | pady = 0  | 单元格上下间距                   |
|          | ipadx = 0 | 单元格内部元素与单元格的左右间距 |
|          | ipady = 0 | 单元格内部元素与单元格的上下间距 |

```
.grid(row = 0,column = 0,padx = 0,pady = 0,ipadx = 0,ipady = 0)
```

| 放置方式 | 参数            | 作用 |
| -------- | --------------- | ---- |
| pack     | `side = 'top'`    | 上   |
|          | `side = 'bottom'` | 下   |
|          | `side = 'left'`   | 左   |
|          | `side = 'right'`  | 右   |

```
.pack(side='top')
```

| 放置方式 | 参数          | 作用   |
| -------- | ------------- | ------ |
| place    | `x = 0`        | 坐标 x |
|          | `y = 0`         | 坐标 y |
|          | `anchor = 'nw'` | 锚定点 |

```
.place(x = 0,y = 0, anchor = 'nw')
```

## 滚动条

滚动条位置

```python
self.slb.place(x=250, y=170,relwidth=0.05, relheight=0.3)
```

## 事件绑定

### 事件序列

0. type 部分的内容是最重要的，它通常用于描述普通的事件类型，例如鼠标点击或键盘按键点击。
0. modifier 部分的内容是可选的，它通常用于描述组合键，例如 Ctrl + c，Shift + 鼠标左键点击。
0. detail 部分的内容是可选的，它通常用于描述具体的按键，例如 Button-1 表示鼠标左键。

| **事件序列**                | **含义**                      | 序列   |
| --------------------------- | ----------------------------- | ------ |
| `<Button-1>`                 | 用户点击鼠标左键              | detail |
| `<KeyPress-H>`               | 用户点击 H 按键               |        |
| `<Control-Shift-KeyPress-H>` | 用户同时点击 Ctrl + Shift + H |        |

### type

| **type**      | **含义**                                                     |
| ------------- | ------------------------------------------------------------ |
| Activate      | 当组件的状态从“未激活”变为“激活”的时候触发该事件             |
| Button        | 1. 当用户点击鼠标按键的时候触发该事件 2. detail 部分指定具体哪个按键：<Button-1>鼠标左键，<Button-2>鼠标中键，<Button-3>鼠标右键，<Button-4>滚轮上滚（Linux），<Button-5>滚轮下滚（Linux） |
| ButtonRelease | 1. 当用户释放鼠标按键的时候触发该事 2. 在大多数情况下，比 Button 要更好用，因为如果当用户不小心按下鼠标，用户可以将鼠标移出组件再释放鼠标，从而避免不小心触发事件 |
| Configure     | 当组件的尺寸发生改变的时候触发该事件                         |
| Deactivate    | 当组件的状态从“激活”变为“未激活”的时候触发该事件             |
| Destroy       | 当组件被销毁的时候触发该事件                                 |
| Enter         | 1. 当鼠标指针进入组件的时候触发该事件 2. 注意：不是指用户按下回车键 |
| Expose        | 当窗口或组件的某部分不再被覆盖的时候触发该事件               |
| FocusIn       | 1. 当组件获得焦点的时候触发该事件 2. 用户可以用 Tab 键将焦点转移到该组件上（需要该组件的 takefocus 选项为 True） 3. 你也可以调用 focus_set() 方法使该组件获得焦点（见上方例子） |
| FocusOut      | 当组件失去焦点的时候触发该事件                               |
| KeyPress      | 1. 当用户按下键盘按键的时候触发该事件 2. detail 可以指定具体的按键，例如 <KeyPress-H>表示当大写字母 H 被按下的时候触发该事件 3. KeyPress 可以简写为 Key |
| KeyRelease    | 当用户释放键盘按键的时候触发该事件                           |
| Leave         | 当鼠标指针离开组件的时候触发该事件                           |
| Map           | 1. 当组件被映射的时候触发该事件 2. 意思是在应用程序中显示该组件的时候，例如调用 grid() 方法 |
| Motion        | 当鼠标在组件内移动的整个过程均触发该事件                     |
| MouseWheel    | 1. 当鼠标滚轮滚动的时候触发该事件 2. 目前该事件仅支持 Windows 和 Mac 系统，Linux 系统请参考 Button |
| Unmap         | 1. 当组件被取消映射的时候触发该事件 2. 意思是在应用程序中不再显示该组件的时候，例如调用 grid_remove() 方法 |
| Visibility    | 当应用程序至少有一部分在屏幕中是可见的时候触发该事件         |

### modifier

在事件序列中，modifier 部分的内容可以是以下这些：

| **modifier** | **含义**                                                     |
| ------------ | ------------------------------------------------------------ |
| Alt          | 当按下 Alt 按键的时候                                        |
| Any          | 1. 表示任何类型的按键被按下的时候 2. 例如 <Any-KeyPress> 表示当用户按下任何按键时触发事件 |
| Control      | 当按下 Ctrl 按键的时候                                       |
| Double       | 1. 当后续两个事件被连续触发的时候 2. 例如 <Double-Button-1> 表示当用户双击鼠标左键时触发事件 |
| Lock         | 当打开大写字母锁定键（CapsLock）的时候                       |
| Shift        | 当按下 Shift 按键的时候                                      |
| Triple       | 跟 Double 类似，当后续三个事件被连续触发的时候               |

### Event 对象

当 Tkinter 去回调你定义的函数的时候，都会带着 Event 对象（作为参数）去调用，Event 对象以下这些属性你可以使用：

| **属性**       | **含义**                                           |
| -------------- | -------------------------------------------------- |
| widget         | 产生该事件的组件                                   |
| x, y           | 当前的鼠标位置坐标（相对于窗口左上角，像素为单位） |
| x_root, y_root | 当前的鼠标位置坐标（相对于屏幕左上角，像素为单位） |
| char           | 按键对应的字符（键盘事件专属）                     |
| keysym         | 按键名，见下方 Key names（键盘事件专属）           |
| keycode        | 按键码，见下方 Key names（键盘事件专属）           |
| num            | 按钮数字（鼠标事件专属）                           |
| width, height  | 组件的新尺寸（Configure 事件专属）                 |
| type           | 该事件类型                                         |

### Key names

当事件为 <Key>，<KeyPress>，<KeyRelease> 的时候，detail 可以通过设定具体的按键名（keysym）来筛选。例如 <Key-H> 表示按下键盘上的大写字母 H 时候触发事件，<Key-Tab> 表示按下键盘上的 Tab 按键的时候触发事件。

（下边按键码是对应美国标准 101 键盘的“Latin-1”字符集，键盘标准不同对应的按键码不同，但按键名是一样的）

| **按键名（keysym）** | **按键码（keycode）** | **代表的按键**               |
| -------------------- | --------------------- | ---------------------------- |
| Alt_L                | 64                    | 左边的 Alt 按键              |
| Alt_R                | 113                   | 右边的 Alt 按键              |
| BackSpace            | 22                    | Backspace（退格）按键        |
| Cancel               | 110                   | break 按键                   |
| Caps_Lock            | 66                    | CapsLock（大写字母锁定）按键 |
| Control_L            | 37                    | 左边的 Ctrl 按键             |
| Control_R            | 109                   | 右边的 Ctrl 按键             |
| Delete               | 107                   | Delete 按键                  |
| Down                 | 104                   | ↓ 按键                       |
| End                  | 103                   | End 按键                     |
| Escape               | 9                     | Esc 按键                     |
| Execute              | 111                   | SysReq 按键                  |
| F1                   | 67                    | F1 按键                      |
| F2                   | 68                    | F2 按键                      |
| F3                   | 69                    | F3 按键                      |
| F4                   | 70                    | F4 按键                      |
| F5                   | 71                    | F5 按键                      |
| F6                   | 72                    | F6 按键                      |
| F7                   | 73                    | F7 按键                      |
| F8                   | 74                    | F8 按键                      |
| F9                   | 75                    | F9 按键                      |
| F10                  | 76                    | F10 按键                     |
| F11                  | 77                    | F11 按键                     |
| F12                  | 96                    | F12 按键                     |
| Home                 | 97                    | Home 按键                    |
| Insert               | 106                   | Insert 按键                  |
| Left                 | 100                   | ← 按键                       |
| Linefeed             | 54                    | Linefeed（Ctrl + J）         |
| KP_0                 | 90                    | 小键盘数字 0                 |
| KP_1                 | 87                    | 小键盘数字 1                 |
| KP_2                 | 88                    | 小键盘数字 2                 |
| KP_3                 | 89                    | 小键盘数字 3                 |
| KP_4                 | 83                    | 小键盘数字 4                 |
| KP_5                 | 84                    | 小键盘数字 5                 |
| KP_6                 | 85                    | 小键盘数字 6                 |
| KP_7                 | 79                    | 小键盘数字 7                 |
| KP_8                 | 80                    | 小键盘数字 8                 |
| KP_9                 | 81                    | 小键盘数字 9                 |
| KP_Add               | 86                    | 小键盘的 + 按键              |
| KP_Begin             | 84                    | 小键盘的中间按键（5）        |
| KP_Decimal           | 91                    | 小键盘的点按键（.）          |
| KP_Delete            | 91                    | 小键盘的删除键               |
| KP_Divide            | 112                   | 小键盘的 / 按键              |
| KP_Down              | 88                    | 小键盘的 ↓ 按键              |
| KP_End               | 87                    | 小键盘的 End 按键            |
| KP_Enter             | 108                   | 小键盘的 Enter 按键          |
| KP_Home              | 79                    | 小键盘的 Home 按键           |
| KP_Insert            | 90                    | 小键盘的 Insert 按键         |
| KP_Left              | 83                    | 小键盘的 ← 按键              |
| KP_Multiply          | 63                    | 小键盘的 * 按键              |
| KP_Next              | 89                    | 小键盘的 PageDown 按键       |
| KP_Prior             | 81                    | 小键盘的 PageUp 按键         |
| KP_Right             | 85                    | 小键盘的 → 按键              |
| KP_Subtract          | 82                    | 小键盘的 - 按键              |
| KP_Up                | 80                    | 小键盘的 ↑ 按键              |
| Next                 | 105                   | PageDown 按键                |
| Num_Lock             | 77                    | NumLock（数字锁定）按键      |
| Pause                | 110                   | Pause（暂停）按键            |
| Print                | 111                   | PrintScrn（打印屏幕）按键    |
| Prior                | 99                    | PageUp 按键                  |
| Return               | 36                    | Enter（回车）按键            |
| Right                | 102                   | → 按键                       |
| Scroll_Lock          | 78                    | ScrollLock 按键              |
| Shift_L              | 50                    | 左边的 Shift 按键            |
| Shift_R              | 62                    | 右边的 Shift 按键            |
| Tab                  | 23                    | Tab（制表）按键              |
| Up                   | 98                    | ↑ 按键                       |

### 捕获鼠标点击坐标

```python
import tkinter as tk
root = tk.Tk()
def callback(event):
        print("点击坐标：", event.x, event.y)

frame = tk.Frame(root, width = 200, height = 200)
frame.bind("<Button-1>", callback)
frame.pack()

root.mainloop()
```

### 获取键盘事件

```python
import tkinter as tk
root = tk.Tk()
def callback(event):
        print("点击的键盘字符为：", event.char)

frame = tk.Frame(root, width = 200, height = 200)
frame.bind("<Key>", callback)
frame.focus_set()
frame.pack()

root.mainloop()
```

### 捕获鼠标在组件上的运动轨迹

```python
# 捕获鼠标在组件上的运动轨迹
import tkinter as tk
root = tk.Tk()

def callback(event):
    print("当前坐标为：", event.x, event.y)

frame = tk.Frame(root, width=200, height=200)
frame.bind("<Motion>", callback)
frame.pack()

root.mainloop()
```

## ERROR

0. 控件和放置最好两行代码，不然有可能返回 None
0. 控件事件函数需要两个参数
0. 导入模块顺序 tkinter 要在 PIL 前

# 大漠插件

```
版本
python 3.4.3
大漠 3.1233

文件
dm.dll
regDll.dll

注册大漠使用管理员身份
regsvr32 dm.dll
```

默认前台，绑定句柄为后台操作。

| 语法                                                         | 返回值 | 作用             | 注意       |
| ------------------------------------------------------------ | ------ | ---------------- | ---------- |
| dm = win32com.client.Dispatch('dm.dmsoft')                   |        | 调用大漠插件     |            |
| print(dm.ver)                                                | 版本号 | 版本号           |            |
| dm.BindWindow(句柄,'dx2','windows','windows',0)              |        | 绑定句柄         |            |
| dm.SetDict(0, "C:\字库.txt")                                 |        | 设置大漠字库     |            |
| dm.GetMousePointWindow()                                     | 句柄   | 获取鼠标指向句柄 |            |
| dm.Ocr(17,262 ,58,280 ,"ffffff-000000",0.9)                  |        | 识别区域文字     |            |
| dm.FindStr(0, 0, 2000, 2000, "回收", "ffffff-000000", 1.0, X, Y) |        | 区域找字         |            |
| dm.FindPic(0,0,2000,2000,r'c:\666.bmp','000000',0.8,0,0,0)   | 坐标   | 区域找图         |            |
| dm.MoveTo(x,y)                                               |        | 鼠标移动位置     |            |
| dm.LeftDown()                                                |        | 鼠标左键按下     |            |
| dm.LeftUp()                                                  |        | 鼠标左键弹起     |            |
| dm.LeftClick()                                               |        | 左键单击         |            |
| dm.LeftDoubleClick()                                         |        | 左键双击         |            |
| dm.KeyPressChar('65')                                        |        | 模拟按键         | 必须为后台 |
| dm.WheelDown()                                               |        | 滚轮向下滚动     |            |
| dm.WheelUp                                                   |        | 滚轮向上滚动     |            |

## 后台找图

```
import win32com.client
import win32api
import win32con

dm = win32com.client.Dispatch('dm.dmsoft')

hwnd = win32gui.FindWindow('SciCalc', '计算器')
hwnd = win32gui.FindWindowEx(hwnd,None,'Window',None)

dm.BindWindow(hwnd,'dx2','windows','windows',0)
xy = dm.FindPic(0,0,2000,2000,r"C:\666.bmp","000000",0.9,0,x,y)
dm.MoveTo(xy[1],xy[2])
dm.LeftDown()
dm.LeftUp()
```

# Excel

## xlwt

打开一个 Excel 后再写数据直接保存就可以了，不用再重新打开

| 语法                                        | 作用                 |
| ------------------------------------------- | -------------------- |
| xlwt_book = xlwt.Workbook(encoding='utf-8') | 新建工作薄           |
| xlwt_sheet = xlwt_book.add_sheet('sheet1')  | 新建 Sheet           |
| xlwt_sheet.write(0,0,'文本')                | 通过行列索引写入数据 |
| xlwt_book.save(r'c:\test.xls')              | 保存                 |

```
from xlwt import *

xlwt_book = Workbook()
xlwt_sheet = xlwt_book.add_sheet('sheet1')

for i in range(1,10):
    style = XFStyle()
    style.num_format_str = 'mm:ss'
    xlwt_sheet.write(i, 0,'文本', style)
    xlwt_sheet.write(0, i, '文本', style)

xlwt_book.save('demo.xls')
```

### 类别

| 语法                                  | 作用               |
| ------------------------------------- | ------------------ |
| style = XFStyle()                     | 实例化类别         |
| style.num_format_str = 'mm:ss'        | 设置类别           |
| xlwt_sheet.write(1, 1, '文本', style) | 根据索引写入单元格 |

```
'general'
'0'
'0.00'
'###0'
'###0.00'
'"$"###0_);("$"###'
'"$"###0_);[Red]("$"###'
'"$"###0.00_);("$"###'
'"$"###0.00_);[Red]("$"###'
'0%'
'0.00%'
'0.00E+00'
'# ?/?'
'# ??/??'
'M/D/YY'
'D-MMM-YY'
'D-MMM'
'MMM-YY'
'h:mm AM/PM'
'h:mm:ss AM/PM'
'h:mm'
'h:mm:ss'
'M/D/YY h:mm'
'_(###0_);(###0)'
'_(###0_);[Red](###0)'
'_(###0.00_);(###0.00)'
'_(###0.00_);[Red](###0.00)'
'_("$"* ###0_);_("$"* (###0);_("$"* "-"_);_(@_)'
'_(* ###0_);_(* (###0);_(* "-"_);_(@_)'
'_("$"* ###0.00_);_("$"* (###0.00);_("$"* "-"??_);_(@_)'
'_(* ###0.00_);_(* (###0.00);_(* "-"??_);_(@_)'
'mm:ss'
'[h]:mm:ss'
'mm:ss.0'
'##0.0E+0'
'@'
```

### 居中

| 语法                          | 作用                  |
| ----------------------------- | --------------------- |
| style = XFStyle()             | 实例化类别            |
| al.horz = 0x02                | 设置水平居中          |
| al.vert = 0x01                | 设置垂直居中          |
| style.alignment = al          | 设置好的参数导入style |
| ws.write(1, 1, '文本', style) | 根据索引写入单元格    |

### 框线与合并

| 语法                                    | 作用                         |
| --------------------------------------- | ---------------------------- |
| borders = Borders()                     | 样式实例化                   |
| borders.left = 2                        | 2号左框线                    |
| borders.right = 2                       | 2号右框线                    |
| borders.top = 2                         | 2号上框线                    |
| borders.bottom = 2                      | 2号下框线                    |
| style.borders = borders                 | 设置好的参数导入 Style       |
| sheet.write_merge(2,2,3,3,'文本',style) | 为第 4 行，第 5 列添加样式   |
| sheet.write_merge(3,3,4,5,'文本',style) | 合并第 3 行，4 和 5 列       |

为 1-10 行添加样式。

```python
for i in range(0, 10):
    borders = Borders()
    borders.left = 2
    borders.right = 2
    borders.top = 2
    borders.bottom = 2
    style.borders = borders
    sheet.write_merge(i,i,1,1,'',style)
```

### 单元格背景色

| 语法                                         | 作用                                |
| -------------------------------------------- | ----------------------------------- |
| style = XFStyle()                            | 赋值 style 为 XFStyle()，初始化样式 |
| pattern = Pattern()                          | 创建一个模式                        |
| pattern.pattern = Pattern.SOLID_PATTERN      | 设置其模式为实型                    |
| pattern.pattern_fore_colour = 1              | 设置单元格背景色                    |
| style.pattern = pattern                      | 将赋值好的模式参数导入 Style        |
| sheet.write_merge(1, 1, 1, 1, '文本', style) | 写入单元格                          |

### 字体样式

| 语法                                    | 作用                                             |
| --------------------------------------- | ------------------------------------------------ |
| style = XFStyle()                       | 赋值 style 为 XFStyle()，实例化样式              |
| fnt = Font()                            | 创建一个文本格式，包括字体，字号和颜色样式特性   |
| fnt.name = u'微软雅黑'                  | 设置字体为微软雅黑                               |
| fnt.colour_index = 1                    | 设置其字体颜色                                   |
| fnt.bold = True                         | 粗体                                             |
| style.font = fnt                        | 将赋值好的模式参数导入 Style                     |
| sheet.write_merge(1,1,1,1,'文本',style) | 写入单元格                                       |

### 列宽与行高

| 语法                                                         | 作用               |
| ------------------------------------------------------------ | ------------------ |
| sheet.col(2).width = 500                                     | 设置第 3 列列宽    |
| tall_style = xlwt.easyxf('font:height 720;')<br>first_row = sheet.row(0) <br>first_row.set_style(tall_style) | 设置行高与字体大小 |

设置所有单元格行高

```python
tall_style = xlwt.easyxf('font:height 400;')
for i in range(65536):
    first_row = sheet.row(i)
    first_row.set_style(tall_style)
```

### 写入公式

| 语法                                       | 作用           |
| ------------------------------------------ | -------------- |
| xlwt_sheet.write(1,1xlwt.Formula('A1*B1')) | 单元格写入公式 |

### 颜色参考

```
from xlwt import *

xlwt_book = Workbook()
xlwt_sheet = xlwt_book.add_sheet('sheet1')
style = XFStyle()

a = 0
for i in range(1000):
    pattern = Pattern()
    pattern.pattern = Pattern.SOLID_PATTERN
    pattern.pattern_fore_colour = i
    style.pattern = pattern
    xlwt_sheet.write(i, 1, None, style)

for i in range(1000):
    xlwt_sheet.write(i, 0, a, style)
    a += 1

xlwt_book.save('demo.xls')
```



## xlrd

| 语法                                                         | 返回值       | 作用                |
| ------------------------------------------------------------ | ------------ | ------------------- |
| xlrd_book = xlrd.open_workbook(r'c:\test.xls')               |              |                     |
| xlrd_book.sheet_names()                                      | list         | 查看所有 sheet 名称 |
| xlrd_sheet = xlrd_book.sheet_by_index(0)                     |              | 通过索引获取 Sheet  |
| xlrd_sheet = xlrd_book.sheets()[0]                           |              | 通过索引获取 Sheet  |
| xlrd_sheet = xlrd_book.sheet_by_name('sheet')                |              | 通过名称获取 Sheet  |
| cell_11 = xlrd_sheet.cell_value(0,0)                         | float \| str | 读取单元格数据      |
| self.xlrd_sheet.cell(0, 1).value                             |              | 可以读取空单元格    |
| row = xlrd_sheet.row_values(3)                               | list         | 读取第 2 行数据     |
| cols = xlrd_sheet.col_values(3)                              | list         | 读取第 2 列数据     |
| [xlrd_sheet.cell(i,ord('B')-ord('A')).value for i in range(0,3)] | list         | 读取 B 列的 1-3 行  |
| xlrd_sheet.nrows                                              | int          | 获取有效行数        |
| xlrd_sheet.ncols                                              |              | 获取有效列数        |

获取单元格的类型

| 语法                       | 返回值 |         |        |
| -------------------------- | ------ | ------- | ------ |
| xlrd_sheet.cell(2,2).ctype | 0      | empty   | 空值   |
|                            | 1      | string  | 字符串 |
|                            | 2      | number  | 数字   |
|                            | 3      | date    | 日期   |
|                            | 4      | boolean | 布尔   |
|                            | 5      | error   | 错误   |

## xlutils

### 保存原始格式追加内容

| 语法                                                         | 作用                             |
| ------------------------------------------------------------ | -------------------------------- |
| xlrd_book = xlrd.open_workbook("C:\\\demo.xls",formatting_info=True) | 读取文件，并保留 Excel 的原格式  |
| xlrd_sheet = xlrd_book.sheets()[0]                           | 获取 sheet 工作表                |
| row = xlrd_sheet.nrows                                       | 获取有效行数                     |
| xlwt_book = copy(xlrd_book)                                  | 将文件复制到内存，并改为写模式   |
| xlwt_sheet = xlwt_book.get_sheet(0)                          | 获取 sheet 工作表                |
| xlwt_sheet.write(row + 1,2,'demo')                           | 写入数据                         |
| xlwt_book.save("C:\\demo.xls")                               | 保存写入数据后的文件到源文件路径 |

````python
import xlrd
from xlutils.copy import copy
xlrd_book = xlrd.open_workbook("C:\\demo.xls",formatting_info=True)
xlrd_sheet = xlrd_book.sheets()[0]
row = xlrd_sheet.nrows
xlwt_book = copy(xlrd_book)
xlwt_sheet = xlwt_book.get_sheet(0)
xlwt_sheet.write(row + 1,2,'demo')
xlwt_book.save("C:\\demo.xls")
````

## pywin32

| 语法                                                  | 作用                                                         |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| excel = win32com.client.Dispatch('Excel.Application') | 获取 excel 对象                                              |
| excel.Visible = -1                                    | 0 代表隐藏对象，但可以通过菜单再显示。<br>  -1 代表显示对象。<br>  2 代表隐藏对象，但不可以通过菜单显示，只能通过 VBA 修改为显示状态。 |
| win32_book = excel.Workbooks.Open("c:/demo.xls")      | 打开 excel                                                   |
| win32_sheet = win32_book.Worksheets("sheet1")         | sheet 页，可以使序号，也可以是名称。                         |
| win32_book.save                                       | 保存                                                         |
| win32_book.close                                      | 退出                                                         |
| LastRow = win32_sheet.usedrange.rows.count            | 获取当前 sheet 页有效行数                                    |

```
from win32com.client import Dispatch
import win32com.client

excel = win32com.client.Dispatch('Excel.Application')
excel.Visible = -1
win32_book = excel.Workbooks.Open(r'c:/demo.xls')
win32_sheet = win32_book.Worksheets('sheet1')
win32_book.save
win32_book.close
```

### 注意

0. 一定要绝对路径
0. 实时操作 Visible = -1

### write

| 语法                                                         | 作用                                     |
| ------------------------------------------------------------ | ---------------------------------------- |
| win32_sheet.Rows("2:500").delete                             | 删除行 2-500 包括 2 和 500               |
| win32_sheet.Cells(2, 2).Value = "233"                        | 写入单元格                               |
| win32_sheet.Cells(2, 2).Font.Color = -16776961               | 设置单元格字体颜色                       |
| win32_sheet.Cells(2, 2).Font.Bold =  True                    | 设置单元格字体为粗体                     |
| win32_sheet.Cells(2, 2).Font.Name = "微软雅黑"               | 设置单元格字体                           |
| win32_sheet.Range(win32_sheet.Cells(6, 1), win32_sheet.Cells(10, 10)).Value = 嵌套元组 | 给一个范围赋值，输入的值应该为嵌套的元组 |
| win32_sheet.Range(win32_sheet.Cells(6, 1), win32_sheet.Cells(10, 10)).Font.Color = -11489280 | 改变一个范围的属性值                     |
| win32_sheet.Range(win32_sheet.Cells(11, 1), win32_sheet.Cells(11, 4)).Value = 元组 | 赋值一行                                 |
| win32_sheet.Rows(12).Value =  元组                           | 赋值一整行                               |

### read

| 语法                                                         | 作用                               |
| ------------------------------------------------------------ | ---------------------------------- |
| aCellValue = win32_sheet.Cells(2, 3).Value                   | 获取一个单元格的值                 |
| 嵌套元组 = win32_sheet.Range(win32_sheet.Cells(1, 1), win32_sheet.Cells(5, 5)).Value | 获取一个范围的值，类型为嵌套的元组 |

### 类别

| 语法                                                  | 作用     |
| ----------------------------------------------------- | -------- |
| win32_sheet.Cells(1, 2).NumberFormatLocal = 'h:mm:ss' | 设置类别 |

### 框线

| 语法                                             | 作用                              |
| ------------------------------------------------ | --------------------------------- |
| win32_sheet.Cells(4, 4).BorderAround(1,3)        | 框线，1 为框线样式 3 为框线粗细   |
| win32_sheet.Range('B2').Borders(1).LineStyle = 7 | 框线，1 设置上下左右 7 为框线样式 |

### 居中

| 语法                                            | 作用     |
| ----------------------------------------------- | -------- |
| win32_sheet.Cells(5, 5).HorizontalAlignment = 3 | 水平居中 |
| win32_sheet.Cells(6, 6).VerticalAlignment = 2   | 垂直居中 |

### 单元格背景色

| 语法                                             | 作用       |
| ------------------------------------------------ | ---------- |
| win32_sheet.Cells(1, 2).Interior.ColorIndex = 28 | 单元格颜色 |

### 合并单元格

| 语法                                                         | 作用       |      |
| ------------------------------------------------------------ | ---------- | ---- |
| win32_sheet.Range(win32_sheet.Cells(1, 1), win32_sheet.Cells(3, 3)) .MergeCells = True | 合并单元格 |      |

### 列宽

| 语法                          | 作用     |
| ----------------------------- | -------- |
| win32_sheet.Columns.AutoFit() | 适应列宽 |

# Access

## pywin32

| 语法                                                         | 作用           |
| ------------------------------------------------------------ | -------------- |
| conn = win32com.client.Dispatch(r"ADODB.Connection")<br>DSN = 'PROVIDER = Microsoft.Jet.OLEDB.4.0;DATA SOURCE = test.mdb'<br>conn.Open(DSN) | 连接数据库     |
| rs = win32com.client.Dispatch(r'ADODB.Recordset')<br>rs_name = '表名'<br>rs.Open('[' + rs_name + ']', conn, 1, 3) | 打开一个记录集 |
| conn.Close()                                                 | 关闭数据库     |

```
import win32com.client

conn = win32com.client.Dispatch(r"ADODB.Connection")
DSN = 'PROVIDER = Microsoft.Jet.OLEDB.4.0;DATA SOURCE = C:\\Users\\Easy Love\\Desktop\\test.mdb'
conn.Open(DSN)

rs = win32com.client.Dispatch(r'ADODB.Recordset')
rs_name = 'test'
rs.Open('[' + rs_name + ']', conn, 1, 3)

conn.Close()
```

### 增

通过索引增加纪录

| 语法                             | 作用                                |
| -------------------------------- | ----------------------------------- |
| rs.AddNew()                      | 添加一条新纪录                      |
| rs.Fields.Item(0).Value = "data" | 设置新记录的第一个值，0 代表第 1 列 |
| rs.Update()                      | 更新                                |

SQL 语言

| 语法                                                         |
| ------------------------------------------------------------ |
| sql_statement = "Insert INTO [表名] ([列名],[列名]) VALUES ('data1', 'data2')" |
| conn.Execute(sql_statement)                                  |

### 删

SQL 语言

### 改

SQL 语言

### 查

| 语法              | 返回值 | 作用             |
| ----------------- | ------ | ---------------- |
| rs.Fields.Count   | int    | 返回一共有多少列 |
| rs.EOF            | 布尔值 |                  |
| rs.MoveFirst()    |        | 光标移到首条记录 |
| rs.Fields[0].Name |        | 根据索引查列名   |

```python
rs.MoveFirst()                                                # 光标移到首条记录
count = 0
while True:
    if rs.EOF:
        break
    else:
        for i in range(rs.Fields.Count):

            print(rs.Fields[i].Name, "：", rs.Fields[i].Value) # 字段名：字段内容
        count += 1
    rs.MoveNext()
```

根据索引察看数据

```python
print(rs.Fields[0].Value) # 第 1 列第 1 个值
rs.MoveNext()
print(rs.Fields[0].Value) # 第 1 列第 2 个值
rs.MoveNext()
```


### 详解

| 语法                    | 返回值 | 作用                                 |
| ----------------------- | ------ | ------------------------------------ |
| rs.MoveFirst()          |        | 第一个                               |
| rs.MoveLast()           |        | 最后一个                             |
| rs.MoveNext()           |        | 下一个                               |
| rs.MovePrevious()       |        | 上一个                               |
| rs.absoluteposition = N |        | 将记录指针移到数据表第 N 行          |
| rs.absolutepage = N     |        | 将记录指针移到第 N 页的第一行        |
| rs.pagesize = N         |        | 设置每页为 N 条记录                  |
| rs.pagecount            |        | 根据 pagesize 的设置返回总页数       |
| rs.recordcount          |        | 返回记录总数                         |
| rs.bof                  | 布尔   | 返回记录指针是否超出数据表首端       |
| rs.eof                  | 布尔   | 返回记录指针是否超出数据表末端       |
| rs.delete               |        | 删除当前记录，但记录指针不会向下移动 |
| rs.addnew               |        | 添加记录到数据表末端                 |
| rs.update               |        | 更新数据表记录                       |

## pypyodbc

| 语法                                                         | 作用           |
| ------------------------------------------------------------ | -------------- |
| str = 'Driver={Microsoft Access Driver (*.mdb)};PWD' + '密码' + ";DBQ=" + 'C:\\test.mdb'<br/>数据链接 = pypyodbc.win_connect_mdb(str) | 建立数据库链接 |
| cur = conn.cursor()                                          | 创建游标       |
| cur.execute(sql 语句)                                        | 执行 sql 语句  |

# 爬虫

## requests

```shell
pip install requests
```

```python
# coding=gbk
import requests

response = requests.get('https://pixivic.com/popSearch')
print(response.status_code) # 打印状态码
print(response.url)         # 打印请求url
print(response.headers)     # 打印头信息
print(response.cookies)     # 打印cookie信息
print(response.text)        # 以文本形式打印网页源码
print(response.content)     # 以字节流形式打印网页源码
```

## xpath

```shell
pip install xlml
```

```python
from lxml import etree
import requests

_requests = requests.get('https://pixivic.com/popSearch')
html_data = etree.HTML(_requests.content)           # 获取 html 源码
ima = html_data.xpath('/html/body/div[5]/img/@src') # 匹配数据
```

## 下载图片

```python
from multiprocessing import Pool
import requests

def _requests(html):
    requests_obj = requests.get(html)
    return requests_obj

def _down(image):
    with open(image[-15:], 'wb+') as f:
        im = _requests(image)
        f.write(im.content)

if __name__ == '__main__':
    images = []
    img = 'http://img.netbian.com/file/2019/0423/f18e61ee804bfee503bc42913883a1a3.jpg'
    images.append(img)
    pool = Pool(1) # 多线程
    pool.map(_down, images)
    pool.close()
    pool.join()
```
